
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Cindy</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Liberty_zheng">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="Cindy">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Cindy">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cindy">

    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Cindy" title="Cindy"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Cindy">Cindy</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/11/29/深入浅出理解word2vec/" title="深入浅出理解word2vec" itemprop="url">深入浅出理解word2vec</a>
  </h1>
  <p class="article-author">By
       
		<a href="/" title="Liberty_zheng" target="_blank" itemprop="author">Liberty_zheng</a>
		
  <p class="article-time">
    <time datetime="2017-11-29T02:21:23.000Z" itemprop="datePublished"> Published 2017-11-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>传统表示文本的模型有以下几个缺点：数据稀疏、词表维度随着语料库增长膨胀，无法衡量词与词之间的语义关系，word2vec模型的提出可以很好的解决这个问题，word2vec是Google在2013年年中开源的一款将词表征为实数值向量的高效工具，采用的模型有CBOW(Continuous Bag-Of-Words，即连续的词袋模型） 和Skip-Gram两种。</p>
<ol>
<li>共现矩阵<br> 首先就是共现矩阵，局域窗口中的word-word共现矩阵可以挖掘语法和语义信息，通常表示在一个窗口中常出现词的关系，windows length 一般设为5-10，且使用对称的窗函数，共现矩阵为对称矩阵，该表示方法仍然存在以下问题：向量维数随着词典的大小线性增长、存储词典空间消耗非常大、文本模型面临稀疏性问题和模型欠稳定，解决以上问题，提出使用降维，如SVD降维，SVD降维存在以下问题：计算量太大( 对X(n,n)矩阵降纬计算量为O(n^3))、难以为辞典中加入的次分配词向量、与其他深度学习模型框架差异大。</li>
<li>NNLM(Neural Network Languuage model)<br> 直接从语言模型出发，将模型最优化过程转换为求词向量表示的过程，目标函数如下：<br> <center><img width="500" height="100" align="center" src="/2017/11/29/深入浅出理解word2vec/nnlm.png"></center><br> 模型使用非对称前向窗口函数，窗长度为n-1，通过滑动窗口遍历整个语料库求和，计算量正比于语料库大小，概率P满足归一化条件，这样不同位置t处的概率才能相加，如下式：<center><img width="500" height="100" align="center" src="/2017/11/29/深入浅出理解word2vec/voc.png"></center><br> 模型结构如下：<br> <center><img width="600" height="100" align="center" src="/2017/11/29/深入浅出理解word2vec/model.png"></center><br> 计算具体流程如下：<br> （1）将C投影矩阵进行初始化；<br> （2）输入层表示为one-hot，并将该向量和prejection layer的投影矩阵进行映射取出对应的列向量；<br> （3）将得到的每个列向量进行拼接，把拼接好的向量和隐藏层进行全联接计算（激活函数一般为tanh）；<br> （4）将上一步得到的量进行一些w组合进行softmax分类，使待预测值的概率最大；<br> （5）使用BP和SGD进行优化（设一个cross-entropy的loss），最终得到投影矩阵C的各个值，训练结束。<br> 计算复杂度：<br> <center><img width="600" height="100" align="center" src="/2017/11/29/深入浅出理解word2vec/nnlm_com.png"></center><br> 每个训练样本的计算复杂度:N×D+N×D×H+H×V， 一个简单模型在大数据量上的表现比复杂模型在少数据量上的表现会好</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/算法/">算法</a>
</div>


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/10/22/身高差最小/" title="身高差最小" itemprop="url">身高差最小</a>
  </h1>
  <p class="article-author">By
       
		<a href="/" title="Liberty_zheng" target="_blank" itemprop="author">Liberty_zheng</a>
		
  <p class="article-time">
    <time datetime="2017-10-22T15:47:10.000Z" itemprop="datePublished"> Published 2017-10-22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>牛家庄幼儿园为庆祝61儿童节举办庆祝活动,庆祝活动中有一个节目是小朋友们围成一个圆圈跳舞。牛老师挑选出n个小朋友参与跳舞节目,已知每个小朋友的身高h_i。为了让舞蹈看起来和谐,牛老师需要让跳舞的圆圈队形中相邻小朋友的身高差的最大值最小,牛老师犯了难,希望你能帮帮他。<br>如样例所示:当圆圈队伍按照100,98,103,105顺时针排列的时候最大身高差为5,其他排列不会得到更优的解<br>思路：先排序 每隔一个去一个数，剩余的数反转  然后组合求醉小差<br>代码如下：</p>
<blockquote>
<pre><code>input()
data=map(int,raw_input().split(&apos; &apos;))
data.sort()
data1=[]
data2=[]
for i in range(len(data)):
    if i%2==0:
        data1.append(data[i])
    else:
        data2.append(data[i])
data=data1+data2[::-1]
maxnum=abs(data[0]-data[-1])
for i in range(1,len(data)):
    if abs(data[i]-data[i-1])&gt;maxnum:
       maxnum= abs(data[i] - data[i - 1])
print maxnum
</code></pre></blockquote>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/算法/">算法</a>
</div>


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/10/20/前序和中序遍历构建二叉树/" title="前序和中序遍历构建二叉树" itemprop="url">前序和中序遍历构建二叉树</a>
  </h1>
  <p class="article-author">By
       
		<a href="/" title="Liberty_zheng" target="_blank" itemprop="author">Liberty_zheng</a>
		
  <p class="article-time">
    <time datetime="2017-10-20T02:48:48.000Z" itemprop="datePublished"> Published 2017-10-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>已知二叉树的前序和中序构建二叉树<br>代码如下：</p>
<blockquote>
<pre><code>class Node:
    def __init__(self, data, left, right):
        self.data=data
        self.left=left
        self.right=right
def construct_tree(preorder,midorder):
    if len(preorder)==0:
        return None
    root_data=preorder[0]
    i=midorder.index(root_data)
    left=construct_tree(preorder[1:i+1],midorder[:i])
    right=construct_tree(preorder[i+1:],midorder[i+1:])
    return Node(root_data,left,right)
if __name__==&apos;__main__&apos;:
    pre_order = [1, 2, 4, 7, 3, 5, 6, 8]
    mid_order = [4, 7, 2, 1, 5, 3, 8, 6]
    root=construct_tree(pre_order,mid_order)
    print root
</code></pre></blockquote>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/算法/">算法</a>
</div>


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/10/19/按层次遍历二叉树与求二叉树深度/" title="按层次遍历二叉树与求二叉树深度" itemprop="url">按层次遍历二叉树与求二叉树深度</a>
  </h1>
  <p class="article-author">By
       
		<a href="/" title="Liberty_zheng" target="_blank" itemprop="author">Liberty_zheng</a>
		
  <p class="article-time">
    <time datetime="2017-10-19T00:42:32.000Z" itemprop="datePublished"> Published 2017-10-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><strong>按层细遍历二叉树</strong><br>思路：利用队列的先进先出思想，将节点一次存入队列，递归弹出遍历直至队列为空，代码如下：</p>
<blockquote>
<pre><code>class node:   #树节点
    def __init__(self,data=None,left=None,right=None):
        self.data=data
        self.left=left
        self.right=right
def level_order(tree):  #按层次遍历
    if tree==None:
        return
    q=[]
    q.append(tree)
    while q:
        tmp=q.pop(0)
        print tmp.data
        if tmp.left!=None:
            q.append(tmp.left)
        if tmp.right!=None:
            q.append(tmp.right)
</code></pre></blockquote>
<p><strong>求二叉树的深度</strong><br>思路：通过递归，如果节点不为空，左右度较深的深度加一，代码如下：</p>
<blockquote>
<pre><code>def depth(tree):
    if tree==None:
        return 0
    left,right=depth(tree.left),depth(tree.right)
    return max(left,right)+1
</code></pre></blockquote>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/算法/">算法</a>
</div>


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/10/18/N皇后问题/" title="N皇后问题" itemprop="url">N皇后问题</a>
  </h1>
  <p class="article-author">By
       
		<a href="/" title="Liberty_zheng" target="_blank" itemprop="author">Liberty_zheng</a>
		
  <p class="article-time">
    <time datetime="2017-10-18T00:07:58.000Z" itemprop="datePublished"> Published 2017-10-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>N皇后问题是一个经典的问题，在一个N<em>N的棋盘上放置N个皇后，每行一个并使其不能互相攻击（同一行、同一列、同一斜线上的皇后都会自动攻击）。<br><em>*思路：</em></em><br>回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。流程如下：</p>
<ol>
<li>算法开始, 清空棋盘，当前行设为第一行，当前列设为第一列</li>
<li>在当前行，当前列的位置上判断是否满足条件(即保证经过这一点的行,列与斜线上都没有两个皇后)，若不满足，跳到第4步</li>
<li>在当前位置上满足条件的情形：<br>  在当前位置放一个皇后，若当前行是最后一行，记录一个解；<br>  若当前行不是最后一行，当前行设为下一行, 当前列设为当前行的第一个待测位置；<br>  若当前行是最后一行，当前列不是最后一列，当前列设为下一列；<br>  若当前行是最后一行，当前列是最后一列，回溯，即清空当前行及以下各行的棋盘，然后，当前行设为上一行，当前列设为当前行的下一个待测位置；<br>  以上返回到第2步</li>
<li>在当前位置上不满足条件的情形：<br>  若当前列不是最后一列，当前列设为下一列，返回到第2步;<br>  若当前列是最后一列了，回溯，即，若当前行已经是第一行了，算法退出，否则，清空当前行及以下各行的棋盘，然后，当前行设为上一行，当前列设为当前行的下一个待测位置，返回到第2步; </li>
</ol>
<p>代码如下：</p>
<blockquote>
<pre><code>class Solution:
# @return a list of lists of string
    def solveNQueens(self, n):
        def check(k,j,board):
            for i in range(k):
                if board[i]==j or abs(k-i)==abs(board[i]-j):
                    return False
            return True
        def dfs(depth,board,valuelist,solution):
        #for i in range(len(board)):
            if depth==len(board):
                solution.append(valuelist)
            for row in range(len(board)):
                if check(depth,row,board):
                    s=&apos;.&apos;*len(board)
                    board[depth]=row
                    dfs(depth+1,board,valuelist+[s[:row]+&apos;Q&apos;+s[row+1:]],solution)
        board=[-1 for i in range(n)]
        solution=[]
        dfs(0,board,[],solution)
        return solution
</code></pre></blockquote>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/算法/">算法</a>
</div>


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/10/18/剑指offer/" title="剑指offer" itemprop="url">剑指offer</a>
  </h1>
  <p class="article-author">By
       
		<a href="/" title="Liberty_zheng" target="_blank" itemprop="author">Liberty_zheng</a>
		
  <p class="article-time">
    <time datetime="2017-10-18T00:07:58.000Z" itemprop="datePublished"> Published 2017-10-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>1.<strong>二维数组的查找</strong><br>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br>思路：首先选取右上角的数字，如果相等，返回查找结果，结束查找，如果该数字大于查找的数字，则剔除该列，如果数字小于要查找数字，则剔除该行，这样每次都可以在数组的查找范围中剔除一行或一列。<br>代码如下：</p>
<blockquote>
<pre><code>def search(arr,n):
     i,j=0,len(arr[0])-1
    while i&lt;len(arr) and j&gt;0:
        if n==arr[i][j]:
            return True
        elif n&gt;arr[i][j]:
            i+=1
        else:
            j-=1
    return False
</code></pre></blockquote>
<p>当然也有效率不高的每行查找，代码如下：</p>
<blockquote>
<pre><code>def search(arr,n):
    for x in arr:
         if n in x:
             return True
     return False
</code></pre></blockquote>
<p>2.<strong>替换空格</strong><br>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br>有如下三个思路：</p>
<p>思路一：创建新的字符串进行替换</p>
<blockquote>
<pre><code>def replaceSpace1(self, s):
    tempstr = &apos;&apos;
    if type(s) != str:
        return
    for c in s:
        if c == &apos; &apos;:
            tempstr += &apos;%20&apos;
        else:
            tempstr += c
    return tempstr
</code></pre></blockquote>
<p>思路二：简单代码替换，在Python中str类型是不可变的类型, 使用replace语句会生成一个新的str, 原始的s还是带空格的str变量</p>
<blockquote>
<pre><code>def replaceSpace2(self, s):
    if type(s) != str:
        return
    return s.replace(&apos; &apos;, &apos;%20&apos;)
</code></pre></blockquote>
<p>思路三：统计空格的个数，将字符串拉长，每多一个空格字符串长度增加2，从后向前，将子串已到相对应的位置</p>
<blockquote>
<pre><code>def replaceSpace3(self, s): # 判断输入类型的时候，isinstance必须首先判断，因为如果输入为integer的话，没有len，就会直接报错
    if not isinstance(s,str) or len(s) &lt;= 0 or s == None:
        return &quot;&quot;
    spaceNum = 0
    for i in s:
        if i == &quot; &quot;:
            spaceNum += 1
    newStrLen = len(s) + spaceNum * 2
    newStr = newStrLen * [None]
    indexOfOriginal, indexOfNew = len(s) - 1, newStrLen - 1
    while indexOfNew &gt;= 0 and indexOfNew &gt;= indexOfOriginal:
        if s[indexOfOriginal] == &apos; &apos;:
            newStr[indexOfNew-2:indexOfNew+1] = [&apos;%&apos;, &apos;2&apos;, &apos;0&apos;]
            indexOfNew -= 3
            indexOfOriginal -= 1
        else:
            newStr[indexOfNew] = s[indexOfOriginal]
            indexOfNew -= 1
            indexOfOriginal -= 1
    return &quot;&quot;.join(newStr)
s = &apos;we are happy&apos;
test = Solution()
print(test.replaceSpace1(s))
print(test.replaceSpace2(s))
print(test.replaceSpace3(s))
</code></pre></blockquote>
<p>3.<strong>从尾到头打印链表</strong><br>输入一个链表，从尾到头打印链表每个节点的值。<br>思路1：定义一个栈，将链表遍历，将节点数值存入栈中，然后依次出栈<br>代码如下：</p>
<blockquote>
<pre><code>class ListNode:
    def __init__(self, x=None):
        self.val = x
        self.next = None    
class Solution:
    def printListFromTailToHead(self, listNode):
        if listNode.val == None:
            return
        l = []
        head = listNode
        while head:
            l.insert(0, head.val)
            head = head.next
        return l
node1 = ListNode(10)
node2 = ListNode(11)
node3 = ListNode(13)
node1.next = node2
node2.next = node3
S = Solution()
print(S.printListFromTailToHead(node1))
</code></pre></blockquote>
<p>思路2:使用递归，打印当前节点的下一个节点的数值<br>代码如下：</p>
<blockquote>
<pre><code>def printListFromTailToHead1(listNode):
    if listNode!=None:
        if listNode.next!=None:
            printListFromTailToHead1(listNode.next)
        print listNode.val
</code></pre></blockquote>
<p>4.<strong>重建二叉树</strong><br>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<br>思路:先序遍历的第一个值为根节点，找在中序遍历中找到该节点的下标，该节点将树分为左右子树，递归的进行建树<br>代码如下：</p>
<blockquote>
<pre><code>class Node:
    def __init__(self, data, left, right):
        self.data=data
        self.left=left
        self.right=right
def construct_tree(preorder,midorder):
    if len(preorder)==0:
        return None
    root_data=preorder[0]
    i=midorder.index(root_data)
    left=construct_tree(preorder[1:i+1],midorder[:i])
    right=construct_tree(preorder[i+1:],midorder[i+1:])
    return Node(root_data,left,right)
if __name__==&apos;__main__&apos;:
    pre_order = [1, 2, 4, 7, 3, 5, 6, 8]
    mid_order = [4, 7, 2, 1, 5, 3, 8, 6]
    root=construct_tree(pre_order,mid_order)
    print root
</code></pre></blockquote>
<p>5.<strong>用两个栈实现队列</strong><br>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<br>思路：定义两个队列，stack1和stack2，如果push，则将数据存入stack1，如果pop，如果stack2中有数据，则直接弹出，否则先将stack1中数据依次弹出存入stack2中，再弹出stack2一个数据。<br>代码如下：</p>
<blockquote>
<pre><code>class Solution:
    def __init__(self):
        self.stack1=[]
        self.stack2=[]
    def push(self, node):
        self.stack1.append(node)
    def pop(self):
        if self.stack2==[]:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        return self.stack2.pop()
</code></pre></blockquote>
<p>6.<strong>二叉树的下一个结点</strong><br>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<blockquote>
<pre><code>class Solution2:
    def GetNext(self, pNode):
        # 输入是一个空节点
        if pNode == None:
            return None
        # 注意当前节点是根节点的情况。所以在最开始设定pNext = None, 如果下列情况都不满足, 说明当前结点为根节点, 直接输出None
        pNext = None
        # 如果输入节点有右子树，则下一个结点是当前节点右子树中最左节点
        if pNode.right:
            pNode = pNode.right
            while pNode.left:
                pNode = pNode.left
            pNext = pNode
        else:
            # 如果当前节点有父节点且当前节点是父节点的左子节点, 下一个结点即为父节点
            if pNode.next and pNode.next.left == pNode:
                pNext = pNode.next
            # 如果当前节点有父节点且当前节点是父节点的右子节点, 那么向上遍历
            # 当遍历到当前节点为父节点的左子节点时, 输入节点的下一个结点为当前节点的父节点
            elif pNode.next and pNode.next.right == pNode:
                pNode = pNode.next
                while pNode.next and pNode.next.right == pNode:
                    pNode = pNode.next
                # 遍历终止时当前节点有父节点, 说明当前节点是父节点的左子节点, 输入节点的下一个结点为当前节点的父节点
                # 反之终止时当前节点没有父节点, 说明当前节点在位于根节点的右子树, 没有下一个结点
                if pNode.next:
                    pNext = pNode.next
        return pNext
</code></pre></blockquote>
<p>7.<strong>斐波那契数列</strong><br>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。<br>思路1:采用循环，时间复杂度为O(n），代码如下：</p>
<blockquote>
<pre><code>def fabci(n):
    if n==0:
        return 0
    a=0
    b=1
    for i in range(n-1):
        a,b=b,a+b
    return b
</code></pre></blockquote>
<p>思路2：采用递归，复杂度较高，会重复计算相同的值<br>代码如下：</p>
<blockquote>
<pre><code>def fab(n):
      if n==1:
        return 1
      if n==0:
        return 0
      else:
        result=int(fab(n-1))+int(fab(n-2))    
    return result
</code></pre></blockquote>
<p>青蛙跳台阶, 每次可以跳1级或2级<br>思路：其实就是斐波那契数列问题，每次可以跳1级或者两级，则下次的可能性为前两次可能性之和</p>
<blockquote>
<pre><code>def jumpFloor(self, number):
 # write code here
 tempArray = [1, 2]
 if number &gt;= 3:
     for i in range(3, number + 1):
         tempArray[(i + 1) % 2] = tempArray[0] + tempArray[1]
 return tempArray[(number + 1) % 2]
</code></pre></blockquote>
<p>8.<strong>旋转数组的最小数字</strong><br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。给出的所有元素都大于0，若数组大小为0，请返回0。<br>思路：如果遍历一遍，复杂度太高，可以采用二分查找，用两个指针分别指向第一个值和最后一个值，取中间的数，如果该数小于最前面的数，则该数在后面递增的数组里，将后面的指针指向该数，否则在前面递增的数组里，将前面的指针指向该数，将更新后的数组重复做以上操作，当两个指针距离是1时结束，返回后面的指针指向的数字。代码如下：</p>
<blockquote>
<pre><code>def minNumberInRotateArray2(rotateArray):
    if len(rotateArray) == 0:
        return 0
    front, rear = 0, len(rotateArray) - 1
    midIndex = 0  #如果数组把前0个数移到后面，则直接返回第一个
    while rotateArray[front] &gt;= rotateArray[rear]:
        if rear - front == 1:
            midIndex = rear
            break
        midIndex = (front + rear) // 2
        if rotateArray[front] == rotateArray[rear] and rotateArray[front] == rotateArray[midIndex]:
            return MinInOrder(rotateArray, front, rear)
        if rotateArray[midIndex] &gt;= rotateArray[front]:
            front = midIndex
        elif rotateArray[midIndex] &lt;= rotateArray[rear]:
            rear = midIndex
    return rotateArray[midIndex]
    def MinInOrder( array, front, end):
        result = array[0]
        for i in array[front:end + 1]:
            if i &lt; result:
                result = i
        return result
    print minNumberInRotateArray2([3,4,5,1,2])
</code></pre></blockquote>
<p>9.矩阵中的路径<br>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。例如 [[a b c e], [s f c s], [a d e e]]矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。<br>思路：递归的采用回溯法</p>
<blockquote>
<pre><code>class Solution:
def hasPath(self, matrix, rows, cols, path):
    if matrix == None or rows &lt; 1 or cols &lt; 1 or path == None:
        return False
    visited = [0] * (rows * cols)
    pathLength = 0
    for row in range(rows):
        for col in range(cols):
            if self.hasPathCore(matrix, rows, cols, row, col, path, pathLength, visited):
                return True
    return False
def hasPathCore(self, matrix, rows, cols, row, col, path, pathLength, visited):
    if len(path) == pathLength:
        return True
    hasPath = False
    if row &gt;= 0 and row &lt; rows and col &gt;= 0 and col &lt; cols and matrix[row * cols + col] == path[pathLength] and not \
    visited[row * cols + col]:
        pathLength += 1
        visited[row * cols + col] = True
        hasPath = self.hasPathCore(matrix, rows, cols, row, col - 1, path, pathLength, visited) or \
                  self.hasPathCore(matrix, rows, cols, row - 1, col, path, pathLength, visited) or \
                  self.hasPathCore(matrix, rows, cols, row, col + 1, path, pathLength, visited) or \
                  self.hasPathCore(matrix, rows, cols, row + 1, col, path, pathLength, visited)
        if not hasPath:
            pathLength -= 1
            visited[row * cols + col] = False
    return hasPath
</code></pre></blockquote>
<p>10.<strong>机器人的运动范围</strong><br>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？<br>思路：机器人从（0，0）开始运动，当它准备进入为（i，j）位置时，判断坐标要求能否进入，如果可以进入，然后递归的进入它相邻的4个格子（i,j-1）,（i-1,j）（i,j+1）,（i+1,j）,采用回溯法，代码如下：</p>
<blockquote>
<pre><code>class Solution:
    def movingCount(self, threshold, rows, cols):
        visited = [False] * (rows * cols)
        count = self.movingCountCore(threshold, rows, cols, 0, 0, visited)
        return count
    def movingCountCore(self, threshold, rows, cols, row, col, visited):
        count = 0
        if self.check(threshold, rows, cols, row, col, visited):
            visited[row * cols + col] = True
            count = 1 + self.movingCountCore(threshold, rows, cols, row-1, col, visited) + \
                        self.movingCountCore(threshold, rows, cols, row+1, col, visited) + \
                        self.movingCountCore(threshold, rows, cols, row, col-1, visited) + \
                        self.movingCountCore(threshold, rows, cols, row, col+1, visited)
        return count
    def check(self, threshold, rows, cols, row, col, visited):
        if row &gt;= 0 and row &lt; rows and col &gt;= 0 and col &lt; cols and self.getDigitSum(row) + self.getDigitSum(col) &lt;= threshold and not visited[row * cols + col]:
            return True
        return False
    def getDigitSum(self, number):
        sum = 0
        while number &gt; 0:
            sum += (number % 10)
            number = number // 10
        return sum
s = Solution()
print(s.movingCount(5, 10, 10))
</code></pre></blockquote>
<p>11.<strong>剪绳子</strong><br>给你一根长度为n的绳子，请把绳子剪成m段 (m和n都是整数，n&gt;1并且m&gt;1)每段绳子的长度记为k[0],k[1],…,k[m].请问k[0]<em>k[1]</em>…<em>k[m]可能的最大乘积是多少？例如，当绳子的长度为8时，我们把它剪成长度分别为2,3,3的三段，此时得到的最大乘积是18.<br>思路1：首先定义函数f(n)为把长度为n的绳子剪成若干段后各段长度乘积的最大值。在剪第一刀时，我们有n-1种选择，也就是说第一段绳子的可能长度分别为1,2,3…..，n-1。因此f(n)=max(f(i)</em>f(n-i))，其中0&lt;i&lt;n。这是一个自上而下的递归公式。由于递归会有大量的不必要的重复计算。一个更好的办法是按照从下而上的顺序计算，也就是说我们先得到f(2),f(3)，再得到f(4),f(5)，直到得到f(n)。当绳子的长度为2的时候，只能剪成长度为1的两段，所以f(2) = 1，当n = 3时，容易得出f(3) = 2;代码如下：</p>
<blockquote>
<pre><code> public class Main {
public static void main(String[] args) {
    System.out.println(maxAfterCutting(8));
}
/**
 * 常规的需要O(n2)的时间复杂度和O(n)的空间复杂度的动态规划思路 题目的意思是:绳子至少是2米，并且必须最少剪一刀。
 */
public static int maxAfterCutting(int length) {
    if (length &lt; 2)
        return 0;
    if (length == 2)
        return 1;
    if (length == 3)
        return 2;
    // 子问题的最优解存储在f数组中，数组中的第i个元素表示把长度为i的绳子剪成若干段后各段长度乘积的最大值。
    int[] f = new int[length + 1];
    f[0] = 0;
    f[1] = 1;
    f[2] = 2;
    f[3] = 3;
    int result = 0;
    for (int i = 4; i &lt;= length; i++) {
        int max = 0;
        for (int j = 1; j &lt;= i / 2; j++) {
            int num = f[j] * f[i - j];
            if (max &lt; num)
                max = num;
        }
        f[i] = max;
    }
    result = f[length];
    return result;
}
</code></pre><p>}</p>
</blockquote>
<p>思路2:贪婪算法，当n&gt;=5时尽可能多的剪长度为3的绳子，剩下剩下的绳子为4时，把绳子剪成两个长度为2的绳子<br>代码如下：</p>
<blockquote>
<pre><code>def long_cut(n):
    if n==3:
        return 2
    if n==2:
        return 1
    if n==0:
        return 0
    counts=0
    for i in range(1,n+1):
        if i%3==0:
            counts+=1
    rest=n-counts*3
    if rest==1:
        return pow(3,counts-1)*4
    elif rest==2:
        return pow(3,counts)*2
    else:
        return pow(3,counts)
    print long_cut(0)
</code></pre></blockquote>
<p>12.<strong>二进制中1的个数</strong><br>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。<br>思路1：先判断整数二进制表示中最右面一位是不是1，接着把输入的整数右移一位，如此反复，直到整数为0<br>代码如下：</p>
<blockquote>
<pre><code>def one_num(n):
counts=0
while n!=0:
    if n&amp;1==1:
        counts+=1
    n=n&gt;&gt;1
return  counts
</code></pre></blockquote>
<p>思路2:调用系统函数，代码如下：</p>
<blockquote>
<pre><code>print bin(n).count(&apos;1&apos;)
</code></pre></blockquote>
<p>思路3:把一个数和该数减一的数做与运算，有多少位1，进行多少次运算，如1100和1011与运算得到1000，代码如下：</p>
<blockquote>
<pre><code>def get_one(n):
    counts=0
    while n!=0:
        counts+=1
        n=n&amp;(n-1)
    return counts
</code></pre></blockquote>
<p>拓展：判断一个数是不是2得整数次幂，代码如下：</p>
<blockquote>
<pre><code>def powerOf2(self, n):
    if n&amp;(n-1) == 0:
        return True
    else:
        return False
</code></pre></blockquote>
<p>拓展：判断两个数的二进制表示有多少位不一样, 直接比较两个数的二进制异或就可以 </p>
<blockquote>
<pre><code>def andOr( m, n):
    diff = m ^ n
    count = 0
    while diff:
        count += 1
        diff = diff &amp; (diff - 1)
    return count
</code></pre></blockquote>
<p>13.<strong>数值的整数次方</strong><br>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br>思路：<br>需要注意的地方:<br>当指数为负数的时候<br>当底数为零切指数为负数的情况<br>在判断底数base是不是等于0的时候,不能直接写base==0, 因为计算机内表示小数时有误差,只能判断他们的差的绝对值是不是在一个很小的范围内<br>当n为偶数, a^n = a^(n/2) <em> a^(n/2)<br>当n为奇数, a^n = a^((n-1)/2) </em> a^((n-1)/2)) * a<br>利用右移一位运算代替除以2<br>利用位与运算代替了求余运算法%来判断一个数是奇数还是偶数<br>优化代码速度<br>代码如下：</p>
<blockquote>
<pre><code>def Power( base, exponent):
    if exponent == 0:
        return 1
    if exponent == 1:
        return base
    if exponent == -1:
        return 1 / base
    result = Power(base, exponent &gt;&gt; 1)
    result *= result
    if (exponent &amp; 0x1) == 1:
        result *= base
    return result
</code></pre></blockquote>
<p>14.<strong>打印从1到最大的n位整数</strong><br>输入数字n, 按顺序打印从1最大的n位十进制数<br>比如输入3, 则打印出1、2、3、到最大的3位数即999<br>思路：用字符串来存储数字</p>
<blockquote>
<pre><code>public class Main {
public static void Print1ToMaxOfNDigits_2(int n) {
    if (n &lt;= 0) {
        return;
    }
    StringBuffer number = new StringBuffer();
    for (int i = 0; i &lt; n; i++) {
        number.append(&apos;0&apos;);
    }
    while (!Increment(number)) {
        PrintNumber(number);
    }
}
public static boolean Increment(StringBuffer s) {
    boolean isOverflow = false;
    int nTakeOver = 0;
    int nLength = s.length();
    for (int i = nLength - 1; i &gt;= 0; i--) {
        int nSum = s.charAt(i) - &apos;0&apos; + nTakeOver;
        if (i == nLength - 1) {
            nSum++;
        }
        if (nSum &gt;= 10) {
            if (i == 0) {
                isOverflow = true;
            } else {
                nSum -= 10;
                nTakeOver = 1;
                s.setCharAt(i, (char) (&apos;0&apos; + nSum));
            }
        } else {
            s.setCharAt(i, (char) (&apos;0&apos; + nSum));
            break;
        }
    }
    return isOverflow;
}
public static void PrintNumber(StringBuffer s) {
    boolean isBeginning0 = true;
    for (int i = 0; i &lt; s.length(); i++) {
        if (isBeginning0 &amp;&amp; s.charAt(i) != &apos;0&apos;) {
            isBeginning0 = false;
        }
        if (!isBeginning0) {
            System.out.print(s.charAt(i));
        }
    }
    System.out.println();
}
public static void main(String[] args) {
    Print1ToMaxOfNDigits_2(2);
}
</code></pre><p> }</p>
</blockquote>
<p>15.<strong>在O(1)时间内删除链表结点</strong><br>给定单向链表的头指针和一个结点指针,定义一个函数在O(1)时间删除该结点<br>思路:将要删除的节点的next复制到当前节点，删除当前节点的next，代码如下：</p>
<blockquote>
<pre><code>class ListNode:
    def __init__(self, x=None):
        self.val = x
        self.next = None
    def __del__(self):
        self.val = None
        self.next = None
class Solution:
    def DeleteNode(self, pListHead, pToBeDeleted):
        if not pListHead or not pToBeDeleted:
            return None
        if pToBeDeleted.next != None:
            pNext = pToBeDeleted.next
            pToBeDeleted.val = pNext.val
            pToBeDeleted.next = pNext.next
            pNext.__del__()
        elif pListHead == pToBeDeleted:
            pToBeDeleted.__del__()
            pListHead.__del__()
        else:
            try:
                pNode = pListHead
                while pNode.next != pToBeDeleted:
                    pNode = pNode.next
                pNode.next = None
                pToBeDeleted.__del__()
            except:
                return False    #如果没有要删除节点
        return True
</code></pre></blockquote>
<p>16.<strong>删除链表中重复的结点</strong><br>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。<br>例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5<br>思路：遍历整个链表，如果当前节点pNode的值和下一个节点的值相同，那么就是重复节点，要删除，我们把当前的前一个节点pPreNode和后面值比当前节点大的值的</p>
<blockquote>
<pre><code>class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
class Solution:
    def deleteDuplication(self, pHead):
        if pHead == None:
            return
        preHead = None
        pNode = pHead
        while pNode != None:
            needDelete = False
            nextNode = pNode.next
            if nextNode != None and nextNode.val == pNode.val:
                needDelete = True
            if needDelete == False:
                preHead = pNode
                pNode = pNode.next
            else:
                nodeVal = pNode.val
                pToBeDel = pNode
                while pToBeDel != None and pToBeDel.val == nodeVal:
                    pToBeDel = pToBeDel.next
                if preHead == None:
                    pHead = pToBeDel
                    pNode = pToBeDel
                    continue
                else:
                    preHead.next = pToBeDel
                pNode = preHead
        return pHead
</code></pre></blockquote>
<p> 17.<strong>正则表达式匹配</strong><br> 请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配<br>代码如下：</p>
<blockquote>
<pre><code>class Solution:
# s, pattern都是字符串
    def match(self, s, pattern):
        if not s or not pattern:
            return False
    # 如果s和pattern匹配, 直接True
        if s == pattern:
            return True
    # 如果pattern为&apos;&apos;, 因为s和pattern不相等, 直接False
        elif pattern == &apos;&apos;:
            return False
    # 当s为&apos;&apos;, 如果pattern为&apos;.&apos;, 则返回True
    # 当s为&apos;&apos;, 如果pattern长度为1且不为&apos;.&apos;, 或者pattern第二个字符不是*, 则pattern不可能为空, 返回False
    # 若pattern长度不为1, 且第二个字符为*, pattern还有空的可能, 从第三个字符开始迭代
        elif s == &apos;&apos;:
            if pattern == &quot;.&quot;:
                return True
            elif len(pattern) == 1 or pattern[1] != &apos;*&apos;:
                return False
            else:
                return self.match(s, pattern[2:])
    # 如果pattern长度不小于二, 而且pattern的第二个字符不是*的情况下
    # 当 pattern[0] 不等于s[0], 且不为 . 的时候, s和pattern必不相等
    # 否则, s 和 pattern 都右移一位, 继续比较
        if len(pattern) &gt;= 2 and pattern[1] != &apos;*&apos;:
            if s[0] != pattern[0] and pattern[0] != &apos;.&apos;:
                return False
            else:
                return self.match(s[1:], pattern[1:])
    # 如果pattern长度不小于2, 且pattern第二个字符为*的情况下
    # 如果s[0]不等于pattern[0], 且pattern[0]不为 . , 那么第一位比较不成功, pattern必须后移两位继续比较后面是否能和s第一位匹配
    # 如果s[0]等于pattern[0], 或者pattern[0]为 . , 第一位匹配, 那么会有
    # 1. aaa 和 a*a 这种情况, 星号代表了多个a, 因此s需要不断右移一位继续比较
    # 2. a 和 a*a 中这情况, 这时候星号代表0个a, 因此s不需要右移, pattern需要右移两位
    # 3. abc 和 a*bc 这种情况, 星号代表了1个a, s右移一位, pattern右移两位继续比较
        elif len(pattern) &gt;= 2 and pattern[1] == &apos;*&apos;:
            if s[0] != pattern[0] and pattern[0] != &apos;.&apos;:
                return self.match(s, pattern[2:])
            else:
                return self.match(s[1:], pattern) or self.match(s, pattern[2:]) or self.match(s[1:], pattern[2:])
    # 除去上述pattern不小于2情况, 只剩下pattern等于1的情况, 因此如果pattern为&quot;.&quot;, 而且s长度为1, 返回True
        elif pattern == &apos;.&apos; and len(s) == 1:
            return True
        return False
s = Solution()
print(s.match(&apos;aaa&apos;, &apos;a*a&apos;))
</code></pre></blockquote>
<p>18.<strong>表示数值的字符串</strong><br>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。<br>思路1：根据规则判断即可，代码如下：</p>
<blockquote>
<pre><code>class Solution:
# s字符串
    def isNumeric(self, s):
        if s == None or len(s) &lt;= 0:
            return False
        aList = [w.lower() for w in s]
        if &apos;e&apos; in aList:
            indexE = aList.index(&apos;e&apos;)
            front = aList[:indexE]
            behind = aList[indexE+1:]
            if &apos;.&apos; in behind or len(behind) == 0:
                return False
            isFront = self.scanDigit(front)
            isBehind = self.scanDigit(behind)
            return isBehind and isFront
        else:
            isNum = self.scanDigit(aList)
            return isNum
    def scanDigit(self, alist):
        dotNum = 0
        allowVal = [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;+&apos;, &apos;-&apos;, &apos;.&apos;, &apos;e&apos;]
        for i in range(len(alist)):
            if alist[i] not in allowVal:
                return False
            if alist[i] == &apos;.&apos;:
                dotNum += 1
            if alist[i] in &apos;+-&apos; and i != 0:
                return False
        if dotNum &gt; 1:
            return False
        return True
# Python trick
</code></pre></blockquote>
<p>思路2:使用巧妙方法，直接将输入字符串进行强制转化为数值型，如果成功则字符串为合法的，否则不合法，代码如下：</p>
<blockquote>
<pre><code>def isNumeric2(self, s):
    try:
        float(s)
        return True
    except:
        return False
print(isNumeric(&apos;-12.5e2&apos;))
</code></pre></blockquote>
<p>19.<strong>调整数组顺序使奇数在偶数前面</strong><br>思路1:定义两个指针front和rear，初始化front指向数组第一个数，rear指向数组最后一个数，在front和rear没有指向同一个指针之前，front向后移动找偶数，rear向前移动找奇数，交换两个数，直至指向同一个数，代码如下：</p>
<blockquote>
<pre><code>class Solution:
# 一个类似于快排的方法, 只是简单的满足了奇数在前,偶数在后, 奇数的顺序发生了改变
    def reOrderArray(self, array):
        if len(array) &lt; 1:
            return
        elif len(array) == 1:
            return array
        front = 0
        rear = len(array)-1
        while front &lt;= rear:
            while array[front] &amp; 0x1 == 1:
                front += 1
            while array[rear] &amp; 0x1 == 0:
                rear -= 1
            array[front], array[rear] = array[rear], array[front]
        array[front], array[rear] = array[rear], array[front]
        return array
</code></pre></blockquote>
<p>思路2:定义两个新数组，分别存储奇数和偶数，然后加到一块，代码如下：</p>
<blockquote>
<pre><code>def reOrderArray3(self, array):
    if len(array) &lt; 1:
        return []
    if len(array) == 1:
        return array
    arrayOdd = []
    arrayEven = []
    for num in array:
        if num &amp; 0x1:
            arrayOdd.append(num)
        else:
            arrayEven.append(num)
    return arrayOdd+arrayEven
</code></pre></blockquote>
<p>思路3:类似于思路2，更简洁的写法，代码如下：</p>
<blockquote>
<pre><code>def reOrderArray2(self, array):
    left = [x for x in array if x &amp; 1]
    right = [x for x in array if not x &amp; 1]
    return left + right
</code></pre></blockquote>
<p>20.<strong>链表中倒数第k个节点</strong><br>输入一个链表，输出该链表中倒数第k个结点。<br>思路：定义两个指针，第一个指针从头节点向后走k-1次，然后第二个指针和第一个指针同时向后走，第一个指针走到最后的尾节点时，第二个指针即指向倒数第k个节点,代码如下：</p>
<blockquote>
<pre><code>class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
class Solution:
    def FindKthToTail(self, head, k):
        if head == None or k &lt;= 0:
            return None
        pAHead = head
        pBehind = None
        for i in range(k-1):
            if pAHead.next != None:
                pAHead = pAHead.next
            else:
                return None
        pBehind = head
        while pAHead.next != None:
            pAHead = pAHead.next
            pBehind = pBehind.next
        return pBehind
node1 = ListNode(10)
node2 = ListNode(11)
node3 = ListNode(13)
node1.next = node2
node2.next = node3
S = Solution()
print(S.FindKthToTail(node1, 2).val)
</code></pre></blockquote>
<p>21.<strong>链表中环的入口节点</strong><br>一个链表中包含环，请找出该链表的环的入口结点。<br>思路：定义两个指针，p1和p2指向头节点，如果链表中的环有n个节点，p1指针先向后走n步，然后两个指针以相同的速度向后移动，当第二个指针指向环入口时，第一个环已经已经绕着环走了一圈，又回到入口处节点，首先求n，用两个指针一快一慢，如果相遇则证明有环，从相遇节点出发，一边向后移动，一边计数，当再次回到该节点时，可以得到环中点的数。代码如下：</p>
<blockquote>
<pre><code>class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
class Solution:
    def MeetingNode(self, pHead):
        if pHead == None:
            return None
        pSlow = pHead.next
        if pSlow == None:
            return None
        pFast = pSlow.next
        while pFast:
            if pSlow == pFast:
                return pSlow
            pSlow = pSlow.next
            pFast = pFast.next
            if pFast:
                pFast = pFast.next
    def EntryNodeOfLoop(self, pHead):
        meetingNode = self.MeetingNode(pHead)
        if not meetingNode:
            return None
        NodeLoop = 1
        flagNode = meetingNode
        while flagNode.next != meetingNode:
            NodeLoop += 1
            flagNode = flagNode.next
        pFast = pHead
        for i in range(NodeLoop):
            pFast = pFast.next
        pSlow = pHead
        while pFast != pSlow:
            pFast = pFast.next
            pSlow = pSlow.next
        return pFast
</code></pre></blockquote>
<p>22.<strong>翻转链表</strong><br>输入一个链表，反转链表后</p>
<blockquote>
<pre><code>class ListNode:
def __init__(self, x):
    self.val = x
    self.next = None
class Solution:
    # 返回ListNode
    def ReverseList(self, pHead):
        pReversedHead = None
        pNode = pHead
        pPrev = None
        while pNode != None:
            pNext = pNode.next
            if pNext == None:
                pReversedHead = pNode
            pNode.next = pPrev
            pPrev = pNode
            pNode = pNext
        return pReversedHead
# 递归实现反转链表
    def ReverseListRec(self, pHead):
        if not pHead or not pHead.next:
            return pHead
        else:
            pReversedHead = self.ReverseList(pHead.next)
            pHead.next.next = pHead
            pHead.next = None
            return pReversedHead
node1 = ListNode(10)
node2 = ListNode(11)
node3 = ListNode(13)
node1.next = node2
node2.next = node3
S = Solution()
p = S.ReverseList(node1)
print(p.val)
</code></pre></blockquote>
<p>23.<strong>合并两个排序链表</strong><br>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。<br>思路：建立一个新的链表，分别比较大小，递归的合并链表，代码如下：</p>
<blockquote>
<pre><code>class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
class Solution:
    # 返回合并后列表
    def Merge(self, pHead1, pHead2):
        if pHead1 == None:
            return pHead2
        elif pHead2 == None:
            return pHead1
        pMergedHead = None
        if pHead1.val &lt; pHead2.val:
            pMergedHead = pHead1
            pMergedHead.next = self.Merge(pHead1.next, pHead2)
        else:
            pMergedHead = pHead2
            pMergedHead.next = self.Merge(pHead1, pHead2.next)
        return pMergedHead
</code></pre></blockquote>
<p>24.<strong>树的子结构</strong><br>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）<br>思路：在A树中找和树B根节点值一样的节点R，再判断树A中以R为根节点的子树是不是包含和B一样的结构，代码如下：</p>
<blockquote>
<pre><code>class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
class Solution:
    def HasSubtree(self, pRoot1, pRoot2):
        result = False
        if pRoot1 != None and pRoot2 != None:
            if pRoot1.val == pRoot2.val:
                result = self.DoesTree1haveTree2(pRoot1, pRoot2)
            if not result:
                result = self.HasSubtree(pRoot1.left, pRoot2)
            if not result:
                result = self.HasSubtree(pRoot1.right, pRoot2)
        return result
    # 用于递归判断树的每个节点是否相同
    # 需要注意的地方是: 前两个if语句不可以颠倒顺序
    # 如果颠倒顺序, 会先判断pRoot1是否为None, 其实这个时候pRoot2的结点已经遍历完成确定相等了, 但是返回了False, 判断错误
    def DoesTree1haveTree2(self, pRoot1, pRoot2):
        if pRoot2 == None:
            return True
        if pRoot1 == None:
            return False
        if pRoot1.val != pRoot2.val:
            return False
        return self.DoesTree1haveTree2(pRoot1.left, pRoot2.left) and self.DoesTree1haveTree2(pRoot1.right, pRoot2.right)
</code></pre></blockquote>
<p>25.<strong>二叉树的镜像</strong><br>操作给定的二叉树，将其变换为源二叉树的镜像。<br>思路：先前序遍历这棵树的每个节点，如果遍历到的节点有子节点，就交换它的两个子节点。<br>递归交换，代码如下：</p>
<blockquote>
<pre><code>class Solution:
    # 递归实现
    def Mirror(self, root):
        if root == None:
            return
        if root.left == None and root.right == None:
            return root
        pTemp = root.left
        root.left = root.right
        root.right = pTemp
        self.Mirror(root.left)
        self.Mirror(root.right)
    # 非递归实现
    def Mirror2(self, root):
        if root == None:
            return
        stackNode = []
        stackNode.append(root)
        while len(stackNode) &gt; 0:
            nodeNum = len(stackNode) - 1
            tree = stackNode[nodeNum]
            stackNode.pop()
            nodeNum -= 1
            if tree.left != None or tree.right != None:
                tree.left, tree.right = tree.right, tree.left
            if tree.left:
                stackNode.append(tree.left)
                nodeNum += 1
            if tree.right:
                stackNode.append(tree.right)
                nodeNum += 1
    # 非递归实现
    def MirrorNoRecursion(self, root):
        if root == None:
            return
        nodeQue = [root]
        while len(nodeQue) &gt; 0:
            curLevel, count = len(nodeQue), 0
            while count &lt; curLevel:
                count += 1
                pRoot = nodeQue.pop(0)
                pRoot.left, pRoot.right = pRoot.right, pRoot.left
                if pRoot.left:
                    nodeQue.append(pRoot.left)
                if pRoot.right:
                    nodeQue.append(pRoot.right)
</code></pre></blockquote>
<p>26.<strong>对称的二叉树</strong><br>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。<br>思路：主要就是把叶子节点的None节点也加入到遍历当中。按照前序遍历二叉树，存入一个序列中。然后按照和前序遍历对应的先父节点，然后右子节点，最后左子节点遍历二叉树，存入一个序列。如果前后两个序列相等，那么说明二叉树是对称的。<br>递归，代码如下：</p>
<blockquote>
<pre><code>class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
class Solution:
    def isSymmetrical(self, pRoot):
         return self.selfIsSymmetrical(pRoot, pRoot)
    def selfIsSymmetrical(self, pRoot1, pRoot2):
        if pRoot1 == None and pRoot2 == None:
            return True
        if pRoot1 == None or pRoot2 == None:
            return False
        if pRoot1.val != pRoot2.val:
            return False
        return self.selfIsSymmetrical(pRoot1.left, pRoot2.right) and self.selfIsSymmetrical(pRoot1.right, pRoot2.left)
</code></pre></blockquote>
<p>非递归实现判断二叉树是否对称,代码如下：</p>
<blockquote>
<pre><code>class Solution2:
    def isSymmetrical(self, pRoot):
        preList = self.preOrder(pRoot)
        mirrorList = self.mirrorPreOrder(pRoot)
        if preList == mirrorList:
            return True
        return False
    def preOrder(self, pRoot):
        if pRoot == None:
            return [None]
        treeStack = []
        output = []
        pNode = pRoot
        while pNode or len(treeStack) &gt; 0:
            while pNode:
                treeStack.append(pNode)
                output.append(pNode.val)
                pNode = pNode.left
                if not pNode:
                    output.append(None)
            if len(treeStack):
                pNode = treeStack.pop()
                pNode = pNode.right
                if not pNode:
                    output.append(None)
        return output
    def mirrorPreOrder(self, pRoot):
        if pRoot == None:
            return [None]
        treeStack = []
        output = []
        pNode = pRoot
        while pNode or len(treeStack) &gt; 0:
            while pNode:
                treeStack.append(pNode)
                output.append(pNode.val)
                pNode = pNode.right
                if not pNode:
                    output.append(None)
            if len(treeStack):
                pNode = treeStack.pop()
                pNode = pNode.left
                if not pNode:
                    output.append(None)
        return output
</code></pre></blockquote>
<p>27.<strong>顺时针打印矩阵</strong><br>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.<br>思路1：首先需要判断每一步开始是的坐标点是否满足小于行数的一半且小于列数的一半，在最后一圈中，可能出现仅能向右走一行，仅能向右走一行向下走一列，向右走一行向下走一列向左走一行，能走完整一圈，一共四种情况。其中只有能向左走一行必然发生，不必判断，剩余的都需要判断发生条件。</p>
<blockquote>
<pre><code>class Solution:
    # matrix类型为二维列表，需要返回列表
    def PrintMatrix(self, matrix):
        printArr = []
        if matrix == None:
            return
        if matrix == []:
            return []
        start = 0               # 每次循环时起始点
        rows = len(matrix)   # 列数
        columns = len(matrix[0])   # 行数
        while columns &gt; 2 * start and rows &gt; 2 * start:
            endX = columns - 1 - start
            endY = rows - 1 - start
            # 从左到右将数字存入printArr
            for i in range(start, endX+1):
                number = matrix[start][i]
                printArr.append(number)
            # 从上到下将数字存入printArr
            if start &lt; endY:
                for i in range(start+1, endY+1):
                    number = matrix[i][endX]
                    printArr.append(number)
            # 从右到左将数字存入printArr
            if start &lt; endX and start &lt; endY:
                for i in range(endX-1, start-1, -1):
                    number = matrix[endY][i]
                    printArr.append(number)
            # 从下到上将数字存入printArr
            if start &lt; endX and start &lt; endY-1:
                for i in range(endY-1, start, -1):
                    number = matrix[i][start]
                    printArr.append(number)
            start += 1
        return printArr
matrix = [[1,  2,  3,  4],
          [5,  6,  7,  8],
          [9, 10, 11, 12],
          [13, 14, 15, 16]]
S = Solution()
print  S.PrintMatrix(matrix)
</code></pre></blockquote>
<p>思路2:这个相对比较容易理解，但复杂度相对高点，每次都打印第一行，然后删除第一行并将矩阵逆时针旋转90度，重复上述操作直到矩阵为空，代码如下：</p>
<blockquote>
<pre><code>class Solution:
    def printMatrix(self, matrix):
        result = []
        while(matrix):
            result+=matrix.pop(0)
            if not matrix or not matrix[0]:
                break
            matrix = self.turn(matrix)
        return result
    def turn(self,matrix):
        num_r = len(matrix)
        num_c = len(matrix[0])
        newmat = []
        for i in range(num_c):
            newmat2 = []
            for j in range(num_r):
                newmat2.append(matrix[j][i])
            newmat.append(newmat2)
        newmat.reverse()
        return newmat
matrix = [[1,  2,  3,  4],
          [5,  6,  7,  8],
          [9, 10, 11, 12],
          [13, 14, 15, 16]]
S = Solution()
print  S.printMatrix(matrix)
</code></pre></blockquote>
<p>28.<strong>包含min函数的栈</strong><br>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。<br>思路：用一个辅助栈一直保存和更新最小值，始终保持栈顶元素最小，第二个第二小，代码如下：</p>
<blockquote>
<pre><code>class Solution:
    def __init__(self):
        self.stack = []
        self.minStack = []
    def push(self, node):
        self.stack.append(node)
        if self.minStack == [] or node &lt; self.min():
            self.minStack.append(node)
        else:
            temp = self.min()
            self.minStack.append(temp)
    def pop(self):
        if self.stack == [] or self.minStack == []:
            return None
        self.minStack.pop()
        self.stack.pop()
    def top(self):
        return self.stack[-1]
    def min(self):
        return self.minStack[-1]
</code></pre></blockquote>
<p>29.<strong>栈的压入、弹出序列</strong><br>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）<br>思路：创建一个辅助栈，压入数据，将该栈栈顶元素与弹出栈栈底元素比较，如果相等则均弹出，如果最后辅助栈为空则返回True否则返回False<br>代码如下：</p>
<blockquote>
<pre><code>class Solution:
    def IsPopOrder2(self, pushV, popV):
        if pushV == [] or popV == []:
            return False
        stack = []
        for i in pushV:
            stack.append(i)
            while len(stack) and stack[-1] == popV[0]:
                stack.pop()
                popV.pop(0)
        if len(stack):
            return False
        else:
            return True
pushV = [1, 2, 3, 4, 5]
popV = [4, 5, 3, 2, 1]
popVF = [4, 5, 2, 1, 3]
S = Solution()
print(S.IsPopOrder2(pushV, popV))
</code></pre></blockquote>
<p>30.<strong>从上到下打印二叉树</strong><br>从上往下打印出二叉树的每个节点，同层节点从左至右打印。<br>思路：如果一个节点有子节点有子节点，则将节点存入到队列尾部，每次从队列的头部取出一个节点操作，重复上述操作，知道队列为空<br>代码如下：</p>
<blockquote>
<pre><code>class TreeNode:
    def __init__(self,val,left=None,right=None):
        self.val=val
        self.left=left
        self.right=right
def printRow(tree):
    q=[tree]
    result=[]
    while q:
        node=q.pop(0)
        result.append(node.val)
        if node.left:
            q.append(node.left)
        if node.right:
            q.append(node.right)
    return result
</code></pre></blockquote>
<p>扩展：分行从上到下打印二叉树<br>思路：定义两个变量，一个表示当前层还没有打印的节点数，另一个表示下一层的节点数，代码如下：</p>
<blockquote>
<pre><code>class TreeNode:
   def __init__(self, x):
       self.val = x
       self.left = None
       self.right = None
class Solution:
    def Print(self, pRoot):
        # write code here
        if pRoot is None:
            return []
        p = [pRoot]
        res = []
        while p:
            node = []
            li = []
            for x in p:
                if x.left:
                    node.append(x.left)
                if x.right:
                    node.append(x.right)
                li.append(x.val)
            p = node
            res.append(li)
        return res
pNode1 = TreeNode(8)
pNode2 = TreeNode(6)
pNode3 = TreeNode(10)
pNode4 = TreeNode(5)
pNode5 = TreeNode(7)
pNode6 = TreeNode(9)
pNode7 = TreeNode(11)
pNode1.left = pNode2
pNode1.right = pNode3
pNode2.left = pNode4
pNode2.right = pNode5
pNode3.left = pNode6
pNode3.right = pNode7
s=Solution()
print(s.Print(pNode1))
</code></pre></blockquote>
<p>31.<strong>之字形打印二叉树</strong><br>请实现一个函数按照之字形打印二叉树，<br>即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。<br>思路：定义两个栈，如果打印的当前时奇数层，现保存左子树节点再保存右子树节点到第一个栈，如果是偶数层，先保存左子树节点再保存右子树节点到第二个栈，代码如下：</p>
<blockquote>
<pre><code>class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
class Solution:
    # 存储点的时候按照奇数层和偶数层分别存储
    def Print(self, pRoot):
        if not pRoot:
            return []
        result, nodes = [], [pRoot]
        right = True
        while nodes:
            curStack, nextStack = [], []
            if right:
                for node in nodes:
                    curStack.append(node.val)
                    if node.left:
                        nextStack.append(node.left)
                    if node.right:
                        nextStack.append(node.right)
            else:
                for node in nodes:
                    curStack.append(node.val)
                    if node.right:
                        nextStack.append(node.right)
                    if node.left:
                        nextStack.append(node.left)
            nextStack.reverse()
            right = not right
            result.append(curStack)
            nodes = nextStack
        return result
</code></pre></blockquote>
<p>思路2:将树进行层次遍历，每行存储到数组里，打印的时候，判断如果下表为奇数则reverse，代码如下</p>
<blockquote>
<pre><code>class TreeNode:
   def __init__(self, x):
       self.val = x
       self.left = None
       self.right = None
class Solution:
    def Print(self, pRoot):
        # write code here
        if pRoot is None:
            return []
        p = [pRoot]
        res = []
        while p:
            node = []
            li = []
            for x in p:
                if x.left:
                    node.append(x.left)
                if x.right:
                    node.append(x.right)
                li.append(x.val)
            p = node
            res.append(li)
        return res
pNode1 = TreeNode(8)
pNode2 = TreeNode(6)
pNode3 = TreeNode(10)
pNode4 = TreeNode(5)
pNode5 = TreeNode(7)
pNode6 = TreeNode(9)
pNode7 = TreeNode(11)
pNode1.left = pNode2
pNode1.right = pNode3
pNode2.left = pNode4
pNode2.right = pNode5
pNode3.left = pNode6
pNode3.right = pNode7
S = Solution()
aList = S.Print(pNode1)
for i in range(len(aList)):
    if i&amp;1==1:
        aList[i].reservse()
        print  aList[i]
    else:
        print aList[i]     
</code></pre></blockquote>
<p>32.<strong>二叉搜索树的后序遍历序列</strong><br>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。<br>思路：在后序遍历的序列中，最后一个数字是树的根节点，数组中前面的数字分为两部分，第一部分是左子树节点的值，他们都比根节点的值小，第二部分是是右子树节点的值，他们都比根节点大，递归的重复上述操作，代码如下：</p>
<blockquote>
<pre><code>class Solution:
    def VerifySquenceOfBST(self, sequence):
        if sequence == []:
            return False
        root = sequence[-1]
        length = len(sequence)
        if min(sequence) &gt; root or max(sequence) &lt; root:
            return True
        index = 0
        # 二叉搜索树的左子树结点小于根节点
        &apos;&apos;&apos;
        下面这个for循环特别需要主要index=i必须写在if语句外面,
        否则就会发生当root结点前的所有元素小于root的时候, 正确判断应该为True,
        但是因为if语句没有进入, index = 0 ,
        在进入二叉搜索树的右子树结点大于根结点的for循环的时候, 因为sequence的数都小于root, 就会判断出错
        &apos;&apos;&apos;
        for i in range(length-1):
            index = i
            if sequence[i] &gt; root:
                break
        # 二叉搜索树的右子树结点大于根结点
        # 这个循环中范围起始点必须是index+1, 不能为index
        # 因为当root结点前的所有元素小于root的时候,index=length-2,
        # 此时sequence[index]&lt;root, 但是按照range(index, length-1), 第一个元素sequence[j]==sequence[index] &lt; root, 返回False, 实际应该返回True才对
        # 而使用index+1, 因为已经默认index&gt;root, 所以从后面一个开始盘算右子树结点是否大于root, 也不会影响结果
        for j in range(index+1, length-1):
            if sequence[j] &lt; root:
                return False
        left = True
        if index &gt; 0:
            left = self.VerifySquenceOfBST(sequence[:index])
        right = True
        if index &lt; length-1:
            right = self.VerifySquenceOfBST(sequence[index:length-1])
        return left and right
array = [5, 7, 6, 9, 11, 10, 8]
array2 = [4, 6, 7, 5]
array3 = [1, 2, 3, 4, 5]
S = Solution()
print(S.VerifySquenceOfBST(array))
print(S.VerifySquenceOfBST(array2))
print(S.VerifySquenceOfBST(array3))
</code></pre></blockquote>
<p>33.<strong>二叉树中和为某一值的路径</strong><br>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。<br>思路：用前序遍历访问到某一节点时，把节点添加到路径上，并累加该节点的值，如果该节点为叶子结点，并且路径节点值刚好等于输入的整数，则符合符合要求，我们把打印出来，如果当前节点不是叶子结点，则继续访问他的叶子结点，当节点访问结束后，递归函数自动回到他的父节点。代码如下:</p>
<blockquote>
<pre><code>class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
class Solution:
    # 优化写法
    def pathSum(self, root, sum):
        if not root: return []
        if root.left == None and root.right == None:
            if sum == root.val:
                return [[root.val]]
            else:
                return []
        a = self.pathSum(root.left, sum - root.val) + self.pathSum(root.right, sum - root.val)
        return [[root.val] + i for i in a]
</code></pre></blockquote>
<p>34.<strong>复杂链表的复制</strong><br>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）<br>思路：将复杂链表中每个节点N创建N‘，并且把N’链接到N的后面，然后把该链表拆分成两个，偶数数位置上的节点组成新的链表。代码如下：</p>
<blockquote>
<pre><code>class RandomListNode:
    def __init__(self, x):
        self.label = x
        self.next = None
        self.random = None
class Solution:
    # 返回 RandomListNode
    def Clone(self, pHead):
        if pHead == None:
            return None
        self.CloneNodes(pHead)
        self.ConnectRandomNodes(pHead)
        return self.ReconnectNodes(pHead)
    # 复制原始链表的每个结点, 将复制的结点链接在其原始结点的后面
    def CloneNodes(self, pHead):
        pNode = pHead
        while pNode:
            pCloned = RandomListNode(0)
            pCloned.label = pNode.label
            pCloned.next = pNode.next
            # pCloned.random = None         #不需要写这句话, 因为创建新的结点的时候,random自动指向None
            pNode.next = pCloned
            pNode = pCloned.next
    # 将复制后的链表中的复制结点的random指针链接到被复制结点random指针的后一个结点
    def ConnectRandomNodes(self, pHead):
        pNode = pHead
        while pNode:
            pCloned = pNode.next
            if pNode.random != None:
                pCloned.random = pNode.random.next
            pNode = pCloned.next
    # 拆分链表, 将原始链表的结点组成新的链表, 复制结点组成复制后的链表
    def ReconnectNodes(self, pHead):
        pNode = pHead
        pClonedHead = pClonedNode = pNode.next
        pNode.next = pClonedHead.next
        pNode = pNode.next
        while pNode:
            pClonedNode.next = pNode.next
            pClonedNode = pClonedNode.next
            pNode.next = pClonedNode.next
            pNode = pNode.next
        return pClonedHead
node1 = RandomListNode(1)
node2 = RandomListNode(3)
node3 = RandomListNode(5)
node1.next = node2
node2.next = node3
node1.random = node3
S = Solution()
clonedNode = S.Clone(node1)
print(clonedNode.random.label)
</code></pre></blockquote>
<p>35.<strong>二叉搜索树与双向链表</strong><br>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<blockquote>
<pre><code>class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
class Solution:
    def Convert(self, pRootOfTree):
        if pRootOfTree == None:
            return None
        if not pRootOfTree.left and not pRootOfTree.right:
            return pRootOfTree
        # 处理左子树
        self.Convert(pRootOfTree.left)
        left = pRootOfTree.left
        # 连接根与左子树最大结点
        if left:
            while left.right:
                left = left.right
            pRootOfTree.left, left.right = left, pRootOfTree
        # 处理右子树
        self.Convert(pRootOfTree.right)
        right = pRootOfTree.right
        # 连接根与右子树最小结点
        if right:
            while right.left:
                right = right.left
            pRootOfTree.right, right.left = right, pRootOfTree
        while pRootOfTree.left:
            pRootOfTree = pRootOfTree.left
        return pRootOfTree
</code></pre></blockquote>
<p>36.<strong>序列化二叉树</strong><br>请实现两个函数，分别用来序列化和反序列化二叉树。这里没有规定序列化的方式。<br>思路：二叉树的序列化就是采用前序遍历二叉树输出节点，再碰到左子节点或者右子节点为None的时候输出一个特殊字符”#”。对于反序列化，就是针对输入的一个序列构建一棵二叉树，我们可以设置一个指针先指向序列的最开始，然后把指针指向位置的数字转化为二叉树的结点，后移一个数字，继续转化为左子树和右子树。当遇到当前指向的字符为特殊字符”#”或者指针超出了序列的长度，则返回None，指针后移，继续遍历。</p>
<blockquote>
<pre><code>class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
class Solution:
    def Serialize(self, root):
        serializeStr = &apos;&apos;
        if root == None:
            return &apos;#&apos;
        stack = []
        while root or stack:
            while root:
                serializeStr += str(root.val) + &apos;,&apos;
                stack.append(root)
                root = root.left
            serializeStr += &apos;#,&apos;
            root = stack.pop()
            root = root.right
        serializeStr = serializeStr[:-1]
        return serializeStr
    def Deserialize(self, s):
        serialize = s.split(&apos;,&apos;)
        tree, sp = self.deserialize(serialize, 0)
        return tree
    def deserialize(self, s, sp):
        if sp &gt;= len(s) or s[sp] == &apos;#&apos;:
            return None, sp + 1
        node = TreeNode(int(s[sp]))
        sp += 1
        node.left, sp = self.deserialize(s, sp)
        node.right, sp = self.deserialize(s, sp)
        return node, sp
</code></pre></blockquote>
<p>37.<strong>字符串的排列</strong><br>输入一个字符串,按字典序打印出该字符串中字符的所有排列。<br>例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。<br>结果请按字母顺序输出。<br>输入描述:<br>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。<br>思路1：先固定一个字符，然后对该字符进行替换，然后再固定两个，直至固定所有</p>
<blockquote>
<pre><code>class Solution:
    def Permutation(self, ss):
        if not len(ss):
            return []
        if len(ss) == 1:
            return list(ss)
        charList = list(ss)
        charList.sort()
        pStr = []
        for i in range(len(charList)):
            if i &gt; 0 and charList[i] == charList[i-1]:
                continue
            temp = self.Permutation(&apos;&apos;.join(charList[:i])+&apos;&apos;.join(charList[i+1:]))
            for j in temp:
                pStr.append(charList[i]+j)
        return pStr
</code></pre></blockquote>
<p>思路2：使用库函数，代码如下：</p>
<blockquote>
<p>  from itertools import permutations<br>    def per(ss):<br>        for x in permutations(ss):<br>            print x</p>
</blockquote>
<p>扩展：扩展习题, 生成字符的所有组合，比如输入abc, 则他们的组合有[‘a’, ‘ab’, ‘abc’, ‘ac’, ‘b’, ‘bc’, ‘c’], ab和ba属于不同的排列, 但属于同一个组合</p>
<blockquote>
<pre><code>def group(self, ss):
    if not len(ss):
        return []
    if len(ss) == 1:
        return list(ss)
    charList = list(ss)
    charList.sort()
    pStr = []
    for i in range(len(charList)):
        pStr.append(charList[i])
        if i &gt; 0 and charList[i] == charList[i - 1]:
            continue
        temp = self.group(&apos;&apos;.join(charList[i + 1:]))
        for j in temp:
            pStr.append(charList[i] + j)
        pStr = list(set(pStr))
        pStr.sort()
    return pStr
</code></pre></blockquote>
<p>38.<strong>数组中出现次数超过半的数字</strong><br>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。<br>思路：保存两个变量，一个是数组中的数字，一个是次数，进行遍历，当下一个数字和保存的数字相同，则次数加一，否则减一，如果次数为零，我们需要保存下一个数字，并把次数设为1，那么要找的数字一定是最后一次把次数设为1对应的数字，代码如下：</p>
<blockquote>
<pre><code>class Solution:
# 检查查找到中位数的元素出现次数是否超过所有元素数量的一半    
    def CheckMoreThanHalf(self, numbers, length, number):
                times = 0
                for i in range(length):
                    if numbers[i] == number:
                        times += 1
                if times*2 &lt;= length:
                    return False
                return True
    # 根据数组特点找出O(n)的算法
    def MoreThanHalfNum(self, numbers):
        length = len(numbers)
        if numbers == None or length &lt;= 0:
            return 0
        result = numbers[0]
        times = 1
        for i in range(1, length):
            if times == 0:
                result = numbers[i]
                times = 1
            elif numbers[i] == result:
                times += 1
            else:
                times -= 1
        if not self.CheckMoreThanHalf(numbers, length, result):
            result = 0
        return result
S = Solution()
</code></pre></blockquote>
<p>思路2：基于快速排序思想，代码如下：<br>基于Partition函数的O(n)算法</p>
<blockquote>
<pre><code>   def MoreThanHalfNum_Solution(self, numbers):
        length = len(numbers)
        if length == 1:
            return numbers[0]
        if self.CheckInvalidArray(numbers, length):
            return 0
        middle = length &gt;&gt; 1
        start = 0
        end = length - 1
        index = self.Partition(numbers, length, start, end)
        while index != middle:
            if index &gt; middle:
                end = index - 1
                index = self.Partition(numbers, length, start, end)
            else:
                start = index + 1
                index = self.Partition(numbers, length, start, end)
        result = numbers[middle]
        if not self.CheckMoreThanHalf(numbers, length, result):
            result = 0
        return result
    # 划分算法
    def Partition(self, numbers, length, start, end):
        if numbers == None or length &lt;= 0 or start &lt; 0 or end &gt;= length:
            return None
        if end == start:
            return end
        pivotvlue = numbers[start]
        leftmark = start + 1
        rightmark = end
        done = False
        while not done:
            while numbers[leftmark] &lt;= pivotvlue and leftmark &lt;= rightmark:
                leftmark += 1
            while numbers[rightmark] &gt;= pivotvlue and rightmark &gt;= leftmark:
                rightmark -= 1
            if leftmark &gt; rightmark:
                done = True
            else:
                numbers[leftmark], numbers[rightmark] = numbers[rightmark], numbers[leftmark]
        numbers[rightmark], numbers[start] = numbers[start], numbers[rightmark]
        return rightmark
    # 检查输入的数组是否合法
    def CheckInvalidArray(self, numbers, length):
        InputInvalid = False
        if numbers == None or length &lt;= 0:
            InputInvalid = True
        return InputInvalid
print(S.MoreThanHalfNum_Solution([1, 2, 3, 2, 2, 2, 5, 4, 2]))
print(S.MoreThanHalfNum_Solution([1, 2, 3, 3, 3, 3, 4]))
print(S.MoreThanHalfNum_Solution([1, 2]))
print(S.MoreThanHalfNum([1, 2, 3, 2, 2, 2, 5, 4, 2]))
print(S.MoreThanHalfNum([1, 2, 3, 3, 3, 3, 4]))
print(S.MoreThanHalfNum([1, 2]))
</code></pre></blockquote>
<p>39.<strong>最小的k个数字</strong><br>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。<br>思路1：基于partion函数，基于数组第k个数字来调整，使得比第k个数字打的数字都位于数组右边，比第k个数字小的所有数字都位于数组左边，数组左边的k个数字就是最小的k个数字（结果不一定是排序的）O（n），代码如下：</p>
<blockquote>
<pre><code>class Solution:
# O(n)的算法, 只有当我们可以修改输入的数组时可用
# 基于Partition的方法
    def GetLeastNumbers_Solution(self, tinput, k):
        if tinput == None or len(tinput) &lt; k or len(tinput) &lt;= 0 or k &lt;=0:
            return []
        n = len(tinput)
        start = 0
        end = n - 1
        index = self.Partition(tinput, n, start, end)
        while index != k-1:
            if index &gt; k-1:
                end = index - 1
                index = self.Partition(tinput, n, start, end)
            else:
                start = index + 1
                index = self.Partition(tinput, n, start, end)
        output = tinput[:k]
        output.sort()
        return output
    def Partition(self, numbers, length, start, end):
        if numbers == None or length &lt;= 0 or start &lt; 0 or end &gt;= length:
            return None
        if end == start:
            return end
        pivotvlue = numbers[start]
        leftmark = start + 1
        rightmark = end
        done = False
        while not done:
            while numbers[leftmark] &lt;= pivotvlue and leftmark &lt;= rightmark:
                leftmark += 1
            while numbers[rightmark] &gt;= pivotvlue and rightmark &gt;= leftmark:
                rightmark -= 1
            if leftmark &gt; rightmark:
                done = True
            else:
                numbers[leftmark], numbers[rightmark] = numbers[rightmark], numbers[leftmark]
        numbers[rightmark], numbers[start] = numbers[start], numbers[rightmark]
        return rightmark
</code></pre></blockquote>
<p>思路2：定义一个大小为k的容器，每次从输入读入一个数，如果容器中已有数字少于k个，直接将这次读入放入容器中，如果已经有k个了，找出已有的k个数中最大值，然后拿待插入的的数字和最大值比较，如果插入值小于该最大值，则替换，否则不替换，用二叉树存储，需要O(logk)时间内完成删除计插入操作。代码如下：</p>
<blockquote>
<pre><code>def GetLeastNumbers(self, tinput, k):
     import heapq
     if tinput == None or len(tinput) &lt; k or len(tinput) &lt;= 0 or k &lt;= 0:
         return []
     output = []
     for number in tinput:
         if len(output) &lt; k:
             output.append(number)
         else:
             # 构造最小堆， 不推荐
             # output = heapq.nsmallest(k, output)
             # if number &gt;= output[-1]:
             #     continue
             # else:
             #     output[-1] = number
             # 构造最大堆， 推荐
             output = heapq.nlargest(k, output)
             if number &gt;= output[0]:
                 continue
             else:
                 output[0] = number
     return output[::-1]     # 最小堆用 return output
</code></pre></blockquote>
<p>40.<strong>数据流中的中位数</strong><br>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。<br>如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。<br>思路：将数据用容器存储，中位数把数据分为两部分，用最大堆实现左面的数据容器，用最小堆实现右面的数据容器，插入一个数据的时间效率是O(logn)，得到堆顶的时间效率为O（1），数据要平均分配到两个堆中，数目之差不能超过1，数据总数如果是偶数是插入最小堆，否则插入最大堆， 代码如下：</p>
<blockquote>
<pre><code>class Solution:
    def __init__(self):
        self.left = []
        self.right = []
        self.count = 0
    def Insert(self, num):
        if self.count &amp; 1 == 0:
            self.left.append(num)
        else:
            self.right.append(num)
        self.count += 1
    def GetMedian(self, x):
        if self.count == 1:
            return self.left[0]
        self.MaxHeap(self.left)
        self.MinHeap(self.right)
        if self.left[0] &gt; self.right[0]:
            self.left[0], self.right[0] = self.right[0], self.left[0]
        self.MaxHeap(self.left)
        self.MinHeap(self.right)
        if self.count &amp; 1 == 0:
            return (self.left[0] + self.right[0])/2.0
        else:
            return self.left[0]
    def MaxHeap(self, alist):
        length = len(alist)
        if alist == None or length &lt;= 0:
            return
        if length == 1:
            return alist
        for i in range(length//2-1, -1, -1):
            k = i; temp = alist[k]; heap = False
            while not heap and 2*k &lt; length-1:
                index = 2*k+1
                if index &lt; length - 1:
                    if alist[index] &lt; alist[index + 1]: index += 1
                if temp &gt;= alist[index]: heap = True
                else:
                    alist[k] = alist[index]
                    k = index
            alist[k] = temp
  def MinHeap(self, alist):
        length = len(alist)
        if alist == None or length &lt;= 0:
            return
        if length == 1:
            return alist
        for i in range(length//2-1, -1, -1):
            k = i; temp = alist[k]; heap = False
            while not heap and 2 * k &lt; length - 1:
                index = 2 * k+1
                if index &lt; length - 1:
                    if alist[index] &gt; alist[index + 1]: index += 1
                if temp &lt;= alist[index]:
                    heap = True
                else:
                    alist[k] = alist[index]
                    k = index
            alist[k] = temp
a=[1,3,2,6,4,7,8,5]
s=Solution()
for x in a:
    s.Insert(x)
print s.GetMedian(a)
</code></pre></blockquote>
<p>41.<strong>连续子数组的最大和</strong><br>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)<br>思路：动态规划，定义一个变量存储最大子数组和，遍历将每个数据相加到一块，如果当前和大于0，则将当前和进入下一轮的求和，否则和为0，并将每个和与最大子数组和比较，如果临时的加和大于最大和则更新最大和，代码如下：</p>
<blockquote>
<pre><code>def max_add(lists):
    maxsums=0
    tmp=0
    for i in range(len(lists)):
        tmp+=lists[i]
        if tmp&gt;maxsums:
            maxsums=tmp
        if tmp&lt;0:
            tmp=0
    return maxsums
print max_add([1,-2,3,10,-4,7,2,-5])
</code></pre></blockquote>
<p>42.<strong>整数中1出现的次数（1到n整数中1出现的次数）</strong><br>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。<br>思路1：从1-n判断每个整数中含有1的个数</p>
<blockquote>
<pre><code>def num(n):
    counts=0
    while n:
        if n%10==1:
            counts+=1
        n/=10
    return counts
def get_num(n):
    sums=0
    for i in range(1,n+1):
        sums+=num(i)
    return sums
print get_num(13)
</code></pre></blockquote>
<p>或者：</p>
<blockquote>
<pre><code>def get_num(n):
    sums=0
    for i in range(1,n+1):
        sums+=str(i).count(&apos;1&apos;)
    return sums
print get_num(13)
</code></pre></blockquote>
<p>思路2:上述复杂度较高，找规律</p>
<blockquote>
<pre><code>class Solution:
    def NumberOf1Between1AndN_Solution(self, n):
        ones, m = 0, 1
        while m &lt;= n:
            ones += (n // m + 8) // 10 * m + (n // m % 10 == 1) * (n % m + 1)
            m *= 10
        return ones
    def NumberOf1Between1AndN2(self, n):
        ones, m = 0, 1
        while m &lt;= n:
            if ((n // m) % 10) != 0 and ((n // m) % 10) != 1:
                ones += (n // 10 // m + 1) * m
            elif ((n // m) % 10) == 1:
                ones += (n // m // 10) * m + n % m + 1
            m *= 10
        return ones
s = Solution()
print(s.NumberOf1Between1AndN_Solution(526))
print(s.NumberOf1Between1AndN2(526))
</code></pre></blockquote>
<p>43.<strong>数字序列中某一位的数字</strong><br>思路1：枚举法，效率低，代码如下：</p>
<blockquote>
<pre><code>def get_numb(n):
    if n&lt;0:
        return -1
    s=&apos;&apos;
    i=0
    while len(s)&lt;=n:
        s+=str(i)
        i+=1
    return s[n]
print get_numb(309)
</code></pre></blockquote>
<p>思路2：根据规律，代码如下：</p>
<blockquote>
<pre><code>class Solution(object):
    def findNthDigit(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        if n &gt; 0:
            k = 1  # k:记录n对应的数字的位数
            while n &gt; k * 9 * 10 ** (k - 1):
                n -= k * 9 * 10 ** (k - 1)
                k += 1
            if n % k == 0:  # t:记录n为第k位上的第几个数
                t = n / k
            else:
                t = n / k + 1
            num = 10 ** (k - 1) + t - 1  # num:记录n对应的十进制数
            temp = n - (t - 1) * k  # temp:记录n对应十进制数num上的第几个数字
            num_list = [0]  # 将num各个数字分解到num_list中
            while num / 10 &gt; 0:
                num_list.append(num % 10)
                num = num / 10
            num_list.append(num)
            num_list = num_list[::-1]
            return num_list[temp - 1]  # 返回num中的第temp个数字
s=Solution()
print s.findNthDigit(100)
</code></pre></blockquote>
<p>44.<strong>把数组排成最小的数</strong><br>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。<br>思路：找出一个排序的比较规则，代码如下：</p>
<blockquote>
<pre><code>def cmp(s1,s2):
    t=str(s1)+str(s2)
    m=str(s2)+str(s1)
    if t&gt;m:
        return 1
    elif t&lt;m:
        return -1
    return 0
def PrintMinNumber( numbers):
    if numbers is None:
        return &quot;&quot;
    lens = len(numbers)
    if lens ==0 :
        return &quot;&quot;
    tmpNumbers = sorted(numbers,cmp=cmp)
    return int(&apos;&apos;.join(str(x)for x in tmpNumbers))
a=[3,32,321]
print PrintMinNumber(a)
</code></pre></blockquote>
<p>45.<strong>把数字翻译成字符串</strong><br>给定一个数字，按照如下规则翻译成字符串：0翻译成“a”，1翻译成“b”…25翻译成“z”。一个数字有多种翻译可能，例如12258一共有5种，分别是bccfi，bwfi，bczi，mcfi，mzi。实现一个函数，用来计算一个数字有多少种不同的翻译方法。<br>思路：自下而上，动态规划，从最小的问题开始 ：<br>f(r)表示以r为开始（r最小取0）到最右端所组成的数字能够翻译成字符串的种数。对于长度为n的数字，f(n)=0,f(n-1)=1,求f(0)。<br>递推公式为 f(r-2) = f(r-1)+g(r-2,r-1)*f(r)；<br>其中，如果r-2，r-1能够翻译成字符，则g(r-2,r-1)=1，否则为0。<br>因此，对于12258：<br>f(5) = 0<br>f(4) = 1<br>f(3) = f(4)+0 = 1<br>f(2) = f(3)+f(4) = 2<br>f(1) = f(2)+f(3) = 3<br>f(0) = f(1)+f(2) = 5<br> 代码如下：</p>
<blockquote>
<pre><code>def counts(s):
    f1,f2,g=0,1,0
    tmp=0
    for i in range(len(s)-2,-1,-1):
        if int(s[i]+s[i+1])&lt;26:
            g=1
        else:
            g=0
        tmp=f2
        f2=f2+g*f1
        f1=tmp
    return f2
def get_counts(n):
    if n&lt;0:
        return 0
    if n==1:
        return 1
    return counts(str(n))
print get_counts(-10)
</code></pre></blockquote>
<p>46.<strong>礼物的最大价值</strong><br>在一个m*n的棋盘的每一格都放有一个礼物，每个礼物具有一定价值（大于0）。从棋盘的左上角开始拿礼物，并每次向右或者向下移动一个，直到达到棋盘的右下角。实现一个函数，给定一个棋盘和上面的礼物，计算能最多拿走多大价值的礼物。<br>思路：这是一个动态规划问题，可用递归的思路来分析；f(i,j)代表到达位置(i,j)时最大礼物价值，则f(i,j)=max[f(i-1,j),f(i,j-1)]+gift(i,j)；</p>
<pre><code>2.    用循环代码来实现。维护一个辅助的二维数组maxValues[rows][cols]，maxValues[i][j]=max(maxValues[i-1][j],maxValues[i][j-1])+giftValues[i][j]。用二重循环最终得到maxValues[rows-1][cols-1]就是最大的礼物价值。
</code></pre><blockquote>
<pre><code>import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int m = input.nextInt();
        int n = input.nextInt();
        int[][] index = new int[m][n];
        index[0][0] = input.nextInt();
        for (int i = 1; i &lt; m; i++) {
            index[0][i] = input.nextInt() + index[0][i - 1];
        }
        for (int i = 1; i &lt; m; i++) {
            index[i][0] = input.nextInt() + index[i - 1][0];
            for (int j = 1; j &lt; n; j++) {
                if (index[i][j - 1] &gt; index[i - 1][j]) {
                    index[i][j] = input.nextInt() + index[i][j - 1];
                } else {
                    index[i][j] = input.nextInt() + index[i - 1][j];
                }
            }
        }
        System.out.println(index[m - 1][n - 1]);
    }
}
</code></pre></blockquote>
<p>47.<strong>最长不含重复数自字符的子字符串</strong><br>思路：动态规划，如果第i个字符之前没有出现过，那么f（i）=f（i-1）+1，如果第i个字符出现过，计算第i个字符上次出现在字符串中的位置的距离d，如果d小于f（i-1）则</p>
<blockquote>
<pre><code>class Solution:
    def lengthOfLongestSubstring(self, s):
        start = maxLength = 0
        usedChar = {}
        for i in range(len(s)):
            if s[i] in usedChar and start &lt;= usedChar[s[i]]:
                start = usedChar[s[i]] + 1
            else:
                maxLength = max(maxLength, i - start + 1)
            usedChar[s[i]] = i
        return maxLength
s=Solution()
print s.lengthOfLongestSubstring(&apos;arabcacfr&apos;)
</code></pre></blockquote>
<p>48.<strong>丑数</strong><br>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。<br>思路1：按照顺序判断是否为丑数，如果为丑数则统计加一，当统计数为N是返回当前的丑数，代码如下：</p>
<blockquote>
<pre><code>def ugly(n):
    if n&lt;=0:
        return False
    for i in [2,3,5]:
        while n%i==0:
            n/=i
    if n==1:
        return True
    else:
        return False
def get_ugly(m):
    j=0
    counts=0
    while  counts&lt;m:
        j+=1
        if ugly(j):
            counts+=1
    return j
print get_ugly(7)
</code></pre></blockquote>
<p>思路2：上个思路需要大量求余和除法，同时也计算了非丑数的数据，浪费时间，空间换时间，创建数组。里面的数字是排好序的丑数，每个丑数都是前面的丑数乘以2、3或者5得到的。把最大的丑数记为M，接下来分析如何生成下一个丑数，该丑数肯定是前面的某个丑数乘以2、3或者5的结果，先考虑把已有的每个丑数乘以2，能得到若干个小于或者等于M的结果和大于M的结果，小于的M的已经在数组里不再考虑，我们只需要第一个大于M的丑数，我们把第一个乘以2大约M的丑数记为M2,同样把每个已有的丑数乘以3和5得到大于M的M3和M5，那么下一个丑数应该是M2、M3和M5中的最小的。在已有的丑数中存在T2乘以2仍然小于当前最大丑数，所以乘以2时，用T2以后的丑数生成新的丑数，T3和T5也存在，生成新的丑数时更新T2，T3，T5，代码如下：</p>
<blockquote>
<pre><code>class Solution:
    def GetUglyNumber_Solution(self, index):
        if index &lt;= 0:
            return 0
        uglyNumbers = [1]*index
        nextIndex = 1
        index2 = 0
        index3 = 0
        index5 = 0
        while nextIndex &lt; index:
            minVal = min(uglyNumbers[index2]*2, uglyNumbers[index3]*3, uglyNumbers[index5]*5)
            uglyNumbers[nextIndex] = minVal
            while uglyNumbers[index2]*2 &lt;= uglyNumbers[nextIndex]:
                index2 += 1
            while uglyNumbers[index3]*3 &lt;= uglyNumbers[nextIndex]:
                index3 += 1
            while uglyNumbers[index5]*5 &lt;= uglyNumbers[nextIndex]:
                index5 += 1
            nextIndex += 1
        return uglyNumbers[-1]
s = Solution()
print(s.GetUglyNumber_Solution(7))
</code></pre></blockquote>
<p>49.<strong>第一次只出现一次的字符</strong><br>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置<br>思路：扫描一遍字符串中的字符并使用hashmap存储，key为字符，value为字符在字符串中出现的次数，第二次扫描，即可找到出现一次的字符，复杂度为O（n），代码如下：</p>
<blockquote>
<pre><code>def first_appear(s):
    if len(s)==0 or s==None:
        return None
    dic={}
    for i in s:
        dic[i]=dic.get(i,0)+1
    for i in s:
        if dic[i]==1:
            return i
    return None
print first_appear(&apos;aabbdbdrgd&apos;)
</code></pre></blockquote>
<p>扩展：字符流中第一个只出现一次的字符,代码如下;</p>
<blockquote>
<pre><code>class Solution:
    def __init__(self):  
        self.string_all = {}  
        self.ch = []  
    def FirstAppearingOnce(self):  
        # write code here  
        if self.string_all is None:  
            return &apos;#&apos;  
        for i in self.ch:  
            if self.string_all[i] == 1:  
                return i  
        return &apos;#&apos;  
    def Insert(self, char):  
        # write code here  
        self.ch.append(char)  
        if char in self.string_all:  
            self.string_all[char] = self.string_all[char] + 1  
        else:  
            self.string_all[char] = 1
s=Solution()
a=&apos;bcbsbdbc&apos;
for x in a:
    s.Insert(x)
print s.FirstAppearingOnce()
</code></pre></blockquote>
<p>50.<strong>数组中的逆序对</strong><br>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007<br>思路1：我们要找到数组中的逆序对，可以看做对数据进行排序，需要交换数组中的元素的次数，但是防止相同大小的元素发生交换，因此需要选择一个稳定的排序方法，记录发生交换的次数。那么，基于比较的稳定的排序方法中，最快的方法就是归并了，所以直接按照归并排序的思路，将数组分解、合并、排序即可。但是需要注意的是，在常规归并排序的时候，如果前一个元素大于后一个元素，直接进行交换即可，只进行了一次操作，但是对于这道题来讲，对于每一次的归并段，我们选择从后向前遍历，前面的归并段的某一个数值left[i]如果大于后面的某一个数值right[j]，因为在right自己独自排序的过程中，已经保证了right是有序的，所以j位置前面的数字全部小于right[j]，所以在这里逆序对的个数就会是 j-start-length，其中start是整个数组的起点，length是left的长度，然后再进行交换。<br>代码如下：</p>
<blockquote>
<pre><code>class Solution:
    def InversePairs(self, data):
        length = len(data)
        if data == None or length &lt;= 0:
            return 0
        copy = [0]*length
        for i in range(length):
            copy[i] = data[i]
        count = self.InversePairsCore(data, copy, 0, length-1)
        return count
    def InversePairsCore(self, data, copy, start, end):
        if start == end:
            copy[start] = data[start]
            return 0
        length = (end - start)//2
        left = self.InversePairsCore(copy, data, start, start+length)
        right = self.InversePairsCore(copy, data, start+length+1, end)
        # i初始化为前半段最后一个数字的下标
        i = start + length
        # j初始化为后半段最后一个数字的下标
        j = end
        indexCopy = end
        count = 0
        while i &gt;= start and j &gt;= start+length+1:
            if data[i] &gt; data[j]:
                copy[indexCopy] = data[i]
                indexCopy -= 1
                i -= 1
                count += j - start - length
            else:
                copy[indexCopy] = data[j]
                indexCopy -= 1
                j -= 1
        while i &gt;= start:
            copy[indexCopy] = data[i]
            indexCopy -= 1
            i -= 1
        while j &gt;= start+length+1:
            copy[indexCopy] = data[j]
            indexCopy -= 1
            j -= 1
        return left + right + count
print(s.InversePairs([364,637,256,936,275,401,497,82,935,874,80,45,848,38,811,267,575]))
</code></pre></blockquote>
<p>思路2：使用数据的index求解，对原数组进行排序并保存为新的数组，然后在新的数组中，求每个数字在原数组的位置，也就是说前面的数字都比该数字大，然后将前面的数字个数相加，知道排完序的数组遍历完成。代码如下：</p>
<blockquote>
<pre><code>    def InversePairs2(self, data):
        if len(data) &lt;= 0:
            return 0
        count = 0
        copy = []
        for i in range(len(data)):
            copy.append(data[i])
        copy.sort()
        i = 0
        while len(copy) &gt; i:
            count += data.index(copy[i])
            data.remove(copy[i])
            i += 1
        return count
s = Solution()
</code></pre></blockquote>
<p>51.<strong>两个链表的第一个公共结点</strong><br>输入两个链表，找出它们的第一个公共结点。<br>思路1：单链表在某个相同的节点后，他们的后续节点都相同，因此我们可以从后向前比较，将两个链表的节点存入栈中，然后比较栈顶元素，如果相同则弹出，最后相同的节点，即为他们的公共节点。代码如下：</p>
<blockquote>
<pre><code>class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
class Solution:
    def FindFirstCommonNode(self, pHead1, pHead2):
        if pHead1==None or pHead2==None:
            return None
        stack1=[]
        stack2=[]
        while pHead1!=None:
            stack1.append(pHead1)
            pHead1=pHead1.next
        while pHead2!=None:
            stack2.append(pHead2)
            pHead2=pHead2.next
        while stack1 and stack2:
            t=stack1.pop()
            q=stack2.pop()
            if stack2[-1]!=stack1[-1]:
                return t
        return None
</code></pre></blockquote>
<p>思路2：求出两个链表的长度差n，让长的链表指针向后移动n次，然后同时移动两个指针，知道找到公共节点，代码如下：</p>
<blockquote>
<pre><code>class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
class Solution:
    def FindFirstCommonNode(self, pHead1, pHead2):
        nLength1 = self.GetListLength(pHead1)
        nLength2 = self.GetListLength(pHead2)
        nLengthDiff = abs(nLength1 - nLength2)
        if nLength1 &gt; nLength2:
            pListHeadLong = pHead1
            pListHeadShort = pHead2
        else:
            pListHeadLong = pHead2
            pListHeadShort = pHead1
        for i in range(nLengthDiff):
            pListHeadLong = pListHeadLong.next
        while pListHeadLong != None and pListHeadShort != None and pListHeadLong != pListHeadShort:
            pListHeadLong = pListHeadLong.next
            pListHeadShort = pListHeadShort.next
        pFirstCommonNode = pListHeadLong
        return pFirstCommonNode
    def GetListLength(self, pHead):
        nLength = 0
        while pHead != None:
            pHead = pHead.next
            nLength += 1
        return nLength
</code></pre></blockquote>
<p>52.<strong>在排序数组中查找数字</strong><br>假设给定一个有序的整型数组arr，以及一个整数 k，问 k在数组中出现了几次？<br>思路1：采用二分查找，找到k第一次出现的下标和最后一次出现的下标，两个相减加一即为k出现的次数，代码如下：</p>
<blockquote>
<pre><code>class Solution:
    def GetNumberOfK(self, data, k):
        # write code here
        if not data:
            return 0
        if len(data) == 1 and data[0] != k:
            return 0
        left = 0
        right = len(data) - 1
        first_k = 0
        while left &lt;= right:
            mid = (left + right) // 2
            if data[mid] &lt; k:
                left = mid + 1
            elif data[mid] &gt; k:
                right = mid - 1
            else:
                if mid == 0:
                    first_k = 0
                    break;
                elif data[mid-1] != k:
                    first_k = mid
                    break;
                else:
                    right = mid - 1       
        left = 0
        right = len(data) - 1
        last_k = -1
        while left &lt;= right:
            mid = (left + right) // 2
            if data[mid] &lt; k:
                left = mid + 1
            elif data[mid] &gt; k:
                right = mid - 1
            else:               
                if mid == len(data) - 1:
                    last_k = len(data) - 1
                    break;
                elif data[mid+1] != k:
                    last_k = mid
                    break;
                else:
                    left = mid + 1       
        return last_k - first_k + 1
s=Solution()
print s.GetNumberOfK([1, 2, 3, 3, 3, 3, 4, 5],3)
</code></pre></blockquote>
<p>思路2：用二分查找，找到一个k的位置，然后在该位置上进行前后查找，效率比思路1差</p>
<p>扩展：0~N-1中缺失的数字<br>一个长度为n-1的递增排序数组中的数字都是唯一的，并且每个数字都在范围之内0~n-1之内，在范围0~n-1内的n个数字中有且仅有一个不再该数组内，请找出改数字。<br>思路1：先用公式n（n-1）/2求出数字0~n-1的所有数字之和，记为s1，然后求出数组之和s2，s1-s2即为缺失的数字，复杂度为O(n)，代码如下：</p>
<blockquote>
<pre><code>def lack(lists):
    s1=len(lists)*(len(lists)+1)/2
    s2=sum(lists)
    return s1-s2
print lack([0,1,2,3,5,6,7])
</code></pre></blockquote>
<p>思路2：数组是排好序的，因此数字和其下标相等，采用二分查找，如果中间元素和下标相等，那么缺失值在后半部分，如果中间元素和下标不相等，它前面的一个元素和下标相等，则中间元素就是第一个和下标不相等的元素，该数字即为所求，如果中间元素和下标不相等且它前面的元素也和下标不相等，则在左面查找，代码如下：</p>
<blockquote>
<pre><code>def lack(lists):
    if len(lists)==0 or lists==None:
        return None
    left=0
    right=len(lists)-1
    while left&lt;=right:
        mid=(left+right)/2
        if lists[mid]==mid:
            left=mid+1
        else:
            if  lists[mid-1]==mid-1:
                return mid
            elif lists[mid-1]!=mid-1:
                right=mid-1
    return lists[mid]
print lack([0,1,2,3,5,6,7])
</code></pre></blockquote>
<p>扩展：数组中数值和下标相等的元素<br>给定一个升序的整数数组A，每个数字唯一，让你在数组中找到任意下标x，使得A[x]== x。（数组下标从0开始）<br>思路：采用二分查找，如果第i个数字大于i，其后面的数字都大于其下标，所以要在左面找，代码如下：</p>
<blockquote>
<pre><code>def equal(lists):
    left=0
    right=len(lists)-1
    while left&lt;=right:
        mid=(left+right)/2
        if lists[mid]==mid:
            return mid
        elif lists[mid]&gt;mid:
            right=mid-1
        else:
            left=mid+1
print equal([-2,0,1,2,3,5,6,7])
</code></pre></blockquote>
<p>53.<strong>二叉搜索树的第k大节点</strong><br>给定一颗二叉搜索树，请找出其中的第k大的结点<br>思路：二叉搜索树的中序遍历是递增的，所以只需要中序便利下树，即可求得第k大的节点<br>代码如下：</p>
<blockquote>
<pre><code>class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
class Solution:
    # 返回对应节点TreeNode
    def __init__(self):
        self.treeNode = []
    def inOrder(self, pRoot):
        if len(self.treeNode) &lt; 0:
            return None
        if pRoot.left:
            self.inOrder(pRoot.left)
        self.treeNode.append(pRoot)
        if pRoot.right:
            self.inOrder(pRoot.right)
    def KthNode(self, pRoot, k):
        if k == 0 or pRoot == None:
            return
        self.inOrder(pRoot)
        if len(self.treeNode) &lt; k:
            return None
        return self.treeNode[k-1]
    def KthNode2(self, pRoot, k):
        if k &lt;= 0 or not pRoot:
            return None
        treeStack, nodesQue = [], []
        pNode = pRoot
        while pNode or len(treeStack):
            while pNode:
                treeStack.append(pNode)
                pNode = pNode.left
            if len(treeStack):
                pNode = treeStack.pop()
                nodesQue.append(pNode)
                pNode = pNode.right
        if k &gt; len(nodesQue):
            return None
        return nodesQue[k-1]
node1=TreeNode(1)
node2=TreeNode(2)
node3=TreeNode(3)
node4=TreeNode(4)
node5=TreeNode(5)
node6=TreeNode(6)
node7=TreeNode(7)
node1.left=node2
node1.right=node3
node2.left=node4
node2.right=node5
node3.left=node6
node3.right=node7
s=Solution()
node=s.KthNode2(node1,3)
print node.val
</code></pre></blockquote>
<p>54.<strong>二叉树的深度</strong><br>输入一棵二叉树，求该树的深度。<br>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度<br>思路：利用递归实现。如果一棵树只有一个结点，那么它的深度为1。递归的时候无需判断左右子树是否存在，因为如果该节点为叶节点，它的左右子树不存在，那么在下一级递归的时候，直接return 0。同时，记得每次递归返回值的时候，深度加一操作。</p>
<blockquote>
<pre><code># -*- coding:utf-8 -*-
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
class Solution:
    # 递归解法, 简单直接, 时间复杂度O(n), 空间复杂度O(logn)
    def depth(self,root):
        if root == None:
            return 0
        return max(self.depth(root.left), self.depth(root.right)) + 1
    # 非递归算法，利用一个栈以及一个标志位栈
    def TreeDepth2(self, pRoot):
        if not pRoot:
            return 0
        depth = 0
        stack, tag = [], []
        pNode = pRoot
        while pNode or stack:
            while pNode:
                stack.append(pNode)
                tag.append(0)
                pNode = pNode.left
            if tag[-1] == 1:
                depth = max(depth, len(stack))
                stack.pop()
                tag.pop()
                pNode = None
            else:
                pNode = stack[-1]
                pNode = pNode.right
                tag.pop()
                tag.append(1)
        return depth
node1=TreeNode(1)
node2=TreeNode(2)
node3=TreeNode(3)
node4=TreeNode(4)
node5=TreeNode(5)
node6=TreeNode(6)
node7=TreeNode(7)
node1.left=node2
node1.right=node3
node2.left=node4
node2.right=node5
node3.left=node6
node3.right=node7
s=Solution()
print s.depth(node1)
</code></pre></blockquote>
<p>扩展：平衡二叉树<br>思路1：基于二叉树的深度，再次进行递归。以此判断左子树的高度和右子树的高度差是否大于1，若是则不平衡，反之平衡。<br>代码如下：</p>
<blockquote>
<pre><code># -*- coding:utf-8 -*-
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
class Solution2:
    def getDepth(self, pRoot):
        if pRoot == None:
            return 0
        return max(self.getDepth(pRoot.left), self.getDepth(pRoot.right)) + 1
    def IsBalanced_Solution(self, pRoot):
        if pRoot == None:
            return True
        if abs(self.getDepth(pRoot.left)-self.getDepth(pRoot.right)) &gt; 1:
            return False
        return self.IsBalanced_Solution(pRoot.left) and self.IsBalanced_Solution(pRoot.right)
pNode1 = TreeNode(1)
pNode2 = TreeNode(2)
pNode3 = TreeNode(3)
pNode4 = TreeNode(4)
pNode5 = TreeNode(5)
pNode6 = TreeNode(6)
pNode7 = TreeNode(7)
pNode1.left = pNode2
pNode1.right = pNode3
pNode2.left = pNode4
pNode2.right = pNode5
pNode3.right = pNode6
pNode5.left = pNode7
S = Solution2()
print(S.IsBalanced_Solution(pNode1))
</code></pre></blockquote>
<p>思路2：思路1中同一个节点会重复求深度，影响性能， 代码如下：</p>
<blockquote>
<pre><code>class Solution(object):
    def isBalanced(self, root):
        stack, node, last, depths = [], root, None, {}
        while stack or node:
            if node:
                stack.append(node)
                node = node.left
            else:
                node = stack[-1]
                if not node.right or last == node.right:
                    node = stack.pop()
                    left, right  = depths.get(node.left, 0), depths.get(node.right, 0)
                    if abs(left - right) &gt; 1: return False
                    depths[node] = 1 + max(left, right)
                    last = node
                    node = None
                else:
                    node = node.right
        return True
</code></pre></blockquote>
<p>55.<strong>数组中只出现一次的数字</strong><br>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字,要求空间复杂度o（1）时间复杂度o（n）.<br>代码如下：</p>
<blockquote>
<pre><code># -*- coding:utf-8 -*-
class Solution:
    # 返回[a,b] 其中ab是出现一次的两个数字
    def FindNumsAppearOnce(self, array):
        if array == None or len(array) &lt;= 0:
            return []
        resultExclusiveOr = 0
        for i in array:
            resultExclusiveOr ^= i
        indexOf1 = self.FindFirstBitIs1(resultExclusiveOr)
        num1, num2 = 0,0
        for j in range(len(array)):
            if self.IsBit1(array[j], indexOf1):
                num1 ^= array[j]
            else:
                num2 ^= array[j]
        return [num1, num2]
    def FindFirstBitIs1(self, num):
        indexBit = 0
        while num &amp; 1 == 0 and indexBit &lt;= 32:
            indexBit += 1
            num = num &gt;&gt; 1
        return indexBit
    def IsBit1(self, num, indexBit):
        num = num &gt;&gt; indexBit
        return num &amp; 1
class Solution2:
    # 返回[a,b] 其中ab是出现一次的两个数字
    def FindNumsAppearOnce(self, array):
        if array == None or len(array) &lt;= 0:
            return []
        resultExOr = self.ExOr(array)
        i = 0
        while resultExOr and i &lt;= 32:
            i += 1
            resultExOr = resultExOr&gt;&gt;1
        num1, num2 = [], []
        for num in array:
            if self.bitIs1(num, i):
                num1.append(num)
            else:
                num2.append(num)
        first = self.ExOr(num1)
        second = self.ExOr(num2)
        return [first, second]
    def ExOr(self, aList):
        ExOrNum = 0
        for i in aList:
            ExOrNum = ExOrNum ^ i
        return ExOrNum
    def bitIs1(self, n, i):
        n = n &gt;&gt; (i-1)
        return n &amp; 1
aList = [2, 4, 3, 6, 3, 2, 5, 5]
s = Solution()
print(s.FindNumsAppearOnce(aList))
</code></pre></blockquote>
<p>扩展：数组中唯一只出现一次的数字<br>在一个数组中除一个数只出现一次外，其他数字都出现了三次，请找出只出现一次的数字</p>
<blockquote>
<pre><code>public int singleNumber(int[] A) {  
       int ones=0;  
       int twos=0;  
       int xthrees=0;  
       for(int i = 0;i &lt;A.length;i++){  
               twos ^= (ones&amp;A[i]);  
               ones ^= A[i];  
               xthrees = ~(ones&amp;twos);  
               twos &amp;= xthrees;  
               ones &amp;=xthrees;  
        }  
        return ones;  
   }  
</code></pre></blockquote>
<p>56.<strong>和为s的两个数字</strong><br>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，<br>如果有多对数字的和等于S，输出两个数的乘积最小的。<br>对应每个测试案例，输出两个数，小的先输出。<br>思路：定义两个指针，前面的指针指向第一个数字，第二个指针指向最后一个数字，当这两个指针指向的数字和大于s时，后面的指针向前移动，如果她们的和小于s时，前面的指针向后移动，O(n),代码如下：</p>
<blockquote>
<pre><code># -*- coding:utf-8 -*-
class Solution:
    # 从左右一起查找
    # 因为当两个数的和一定的时候, 两个数字的间隔越大, 乘积越小
    # 所以直接输出查找到的第一对数即可
    def FindNumbersWithSum(self, array, tsum):
        if array == None or len(array) &lt;= 0 or array[-1] + array[-2] &lt; tsum:
            return []
        start = 0
        end = len(array)-1
        while start &lt; end:
            sum = array[start] + array[end]
            if sum &lt; tsum:
                start += 1
            elif sum &gt; tsum:
                end -= 1
            else:
                return [array[start], array[end]]
        return []
test = [1,2,4,7,11,15]
s = Solution()
print(s.FindNumbersWithSum(test, 15))
</code></pre></blockquote>
<p>扩展：和为s的连续整数序列<br>思路：设定两个指针，先分别指向数字1和数字2，并设这两个指针为small和big，对small和big求和，如果和大于目标值，则从当前和中删除small值，并把small值加一，如果和小于目标值，则把big值加一，再把新的big值加入和中。如果和等于目标值，就输出small到big的序列，同时把big加一并加入和中，继续之前的操作。</p>
<blockquote>
<pre><code># -*- coding:utf-8 -*-
class Solution:
    def FindContinuousSequence(self, tsum):
        # write code here
        A=[]
        for i in range(1,tsum):
            sum=i
            B=[]
            B.append(i)
            i=i+1
            sum+=i
            B.append(i)
            while sum&lt;tsum:
                i+=1
                sum=i+sum
                B.append(i)
            if sum==tsum:
                A.append(B)
        return A
test = [1,2,4,7,11,15]
s = Solution()
print(s.FindContinuousSequence(100))
</code></pre></blockquote>
<p>57.<strong>翻转单词顺序</strong><br>输入一个英文句子, 翻转句子中单词的顺序,但单词内字符的顺序不变，为简单起见, 标点符号和普通字母一样处理，I am a student. 输出student. a am I<br>思路1：先反转所有字符，然后再以单词为单位翻转单词内部字符，代码如下：</p>
<blockquote>
<pre><code>class Solution:
    # 按照书上的方法进行编写
    # 因为Python的字符串结束没有结束符, 所以需要判断最后的pEnd是否已经指到最后一个字符
    # 如果已经指到最后一个字符, 则直接在复制之后跳出循环
    # 测试用例&apos;I am a student.&apos;和&apos; &apos;和&apos;&apos;
    def ReverseSentence(self, s):
        if s == None or len(s) &lt;= 0:
            return &apos;&apos;
        strList = list(s)
        strList = self.Reverse(strList)
        pBegin = 0
        pEnd = 0
        resultStr = &apos;&apos;
        listTemp = []
        while pEnd &lt; len(s):
            # 如果字符串长度为1, 直接跳出循环
            # 如果pEnd指针指到最后一个字符, 跳出循环
            if pEnd == len(s)-1:
                listTemp.append(self.Reverse(strList[pBegin:]))
                break
            # 这个判断语句位置需要靠前, 用来鉴定字符串开头是否是空格的情况
            if strList[pBegin] == &apos; &apos;:
                pBegin += 1
                pEnd += 1
                listTemp.append(&apos; &apos;)
            elif strList[pEnd] == &apos; &apos;:
                listTemp.append(self.Reverse(strList[pBegin:pEnd]))
                pBegin = pEnd
            else:
                pEnd += 1
        # print(listTemp)
        for i in listTemp:
            resultStr += &apos;&apos;.join(i)
        return resultStr
    # 翻转字符list
    def Reverse(self, alist):
        if alist == None or len(alist) &lt;= 0:
            return &apos;&apos;
        startIndex = 0
        endIndex = len(alist) - 1
        while startIndex &lt; endIndex:
            alist[startIndex], alist[endIndex] = alist[endIndex], alist[startIndex]
            startIndex += 1
            endIndex -= 1
        return alist
</code></pre></blockquote>
<p>思路2:使用pythonic</p>
<blockquote>
<pre><code>def ReverseSentence2(self, s):
    l = s.split(&apos; &apos;)
    return &apos; &apos;.join(l[::-1])
</code></pre></blockquote>
<p>扩展：坐旋转字符串<br>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。<br>对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。<br>例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。<br>思路1：把字符串分成两个部分，一部分是要后移的，一部分后面不动的，分别将两个进行反转，然后整体翻转，代码如下：</p>
<blockquote>
<pre><code># -*- coding:utf-8 -*-
class Solution:
    def LeftRotateString(self, s, n):
        if len(s) &lt;= 0 or len(s) &lt; n or n &lt; 0:
            return &apos;&apos;
        strList= list(s)
        self.Reverse(strList)
        length = len(s)
        pivot = length - n
        frontList = self.Reverse(strList[:pivot])
        behindList = self.Reverse(strList[pivot:])
        resultStr = &apos;&apos;.join(frontList) + &apos;&apos;.join(behindList)
        return resultStr
    def Reverse(self, alist):
        if alist == None or len(alist) &lt;= 0:
            return &apos;&apos;
        startIndex = 0
        endIndex = len(alist) - 1
        while startIndex &lt; endIndex:
            alist[startIndex], alist[endIndex] = alist[endIndex], alist[startIndex]
            startIndex += 1
            endIndex -= 1
        return alist
test = &apos;abcdefg&apos;
s = Solution()
print(s.LeftRotateString(test, 2))
</code></pre></blockquote>
<p>思路2:pythonic</p>
<blockquote>
<pre><code>class Solution:
    def Reverse(self, alist,k):
        return alist[k:]+alist[:k]
test = &apos;abcdefg&apos;
s = Solution()
print(s.Reverse(test, 2))
</code></pre></blockquote>
<p>58.<strong>队列的最大值</strong><br>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。<br>例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，<br>他们的最大值分别为{4,4,6,6,6,5}；针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个：<br>{[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<blockquote>
<pre><code># -*- coding:utf-8 -*-
class Solution:
    def maxInWindows(self, num, size):
        if not num or size &lt;= 0:
            return []
        deque = []
        if len(num) &gt;= size:
            index = []
            for i in range(size):
                while len(index) &gt; 0 and num[i] &gt; num[index[-1]]:
                    index.pop()
                index.append(i)
            for i in range(size, len(num)):
                deque.append(num[index[0]])
                while len(index) &gt; 0 and num[i] &gt;= num[index[-1]]:
                    index.pop()
                if len(index) &gt; 0 and index[0] &lt;= i - size:
                    index.pop(0)
                index.append(i)
            deque.append(num[index[0]])
        return deque
test = [2, 3, 4, 2, 6, 2, 5, 1]
s = Solution()
print(s.maxInWindows(test, 3))
</code></pre></blockquote>
<p>扩展：队列的最大值<br>思路：滑动窗口可以看成一个队列，上题的解法可以用来实现带max函数的队列，用两个栈设计一个新的数据类型（数据类型定义为MyStack），其中一个栈用来存放数据,另一个栈用来存放最大值，</p>
<p>当插入数据时，第一个栈接受数据进行入栈操作，第二栈首先判断一下栈顶元素和插入元素的大小，如果栈顶元素小于新插入的元素，那么，第二个堆栈进行入栈操作，如果栈顶元素小于新插入的元素的大小，第二个栈不做操作！！！</p>
<p>当删除元素时，第一个栈直接进行出栈操作，第二个栈拿出栈顶元素和第一个栈中出栈元素进行比较，如果相等，第二个栈进行出栈操作，否则不做操作，第二个栈的栈顶元素就是最大值，代码如下：</p>
<blockquote>
<pre><code>import java.util.Stack;
public class MyStack {
    private Stack&lt;integer&gt; stack1 = new Stack&lt;integer&gt;();
    private Stack&lt;integer&gt; stack2 = new Stack&lt;integer&gt;();
    public void push(int e) {
        stack1.push(e);
        if (stack2.size() == 0 || stack2.peek() &lt; e) {
            stack2.push(e);
        }
    }
    public int pop() {
        int temp = stack1.pop();
        if (temp == stack2.peek()) {
            stack2.pop();
        }
        return temp;
    }
    public int max() {
        if (stack2.size() != 0) {
            return stack2.peek();
        } else {
            return 0;
        }
    }
    public int size() {
        return stack1.size();
    }
    public static void main(String[] args) {
        MyStack myStack = new MyStack();
        myStack.push(4);
        myStack.push(8);
        myStack.push(6);
        myStack.push(5);
        myStack.push(3);
        myStack.push(9);
        myStack.push(3);
        myStack.push(14);
        System.out.println(myStack.max());
        myStack.pop();
        myStack.pop();
        myStack.pop();
        System.out.println(myStack.max());
    }
}
</code></pre></blockquote>
<p>59.<strong>n个骰子的点数</strong><br>把n个骰子扔在地上, 所有骰子朝上一面的点数和为s。输入n, 打印出s的所有可能的值出现的概率<br>思路：用两个数组来存储骰子点数的每一个总数出现次数。在一次循环中，第一个数组中的第n个数字表示骰子和为n出现的次数。在下一次循环中加入一个新的骰子，此时和为n的骰子出现的次数应该等于上一次循环中骰子点数和为n-1，n-2，n-3，n-4，n-5，n-6的次数的总和，也就是把另一个数组的第n个数字对应上一个数组的n-1，n-2，n-3，n-4，n-5，n-6的次数的总和。同时需要注意的是，每次使用新数组的时候，需要把数组所有位置清零，因为我们对于第n位进行的累加操作，如果之前第n位有数字但不清零的话，会导致结果偏大。代码如下：</p>
<blockquote>
<pre><code># 基于循环求点数, 时间性能好
def PrintProbability(number):
    if number &lt; 1:
        return
    maxVal = 6
    # 构造两个数组来存储骰子点数的每一个总数出现的次数
    # 在一次循环中, 第一个数组中的第n个数字表示骰子和为n出现的次数
    # 在下次循环中, 另一个数组的第n个数字设为前一个数组对应的第n-1、n-2、n-3、n-4、n-5、n-6之和
    probStorage = [[], []]
    probStorage[0] = [0]*(maxVal * number + 1)
    flag = 0
    for i in range(1, maxVal+1):
        probStorage[flag][i] = 1
    for time in range(2, number+1):
        probStorage[1-flag] = [0]*(maxVal * number + 1)
        for pCur in range(time, maxVal*time+1):
            diceNum = 1
            while diceNum &lt; pCur and diceNum &lt;= maxVal:
                probStorage[1-flag][pCur] += probStorage[flag][pCur-diceNum]
                diceNum += 1
        flag = 1 - flag
    total = maxVal ** number
    for i in range(number, maxVal*number+1):
        ratio = probStorage[flag][i] / float(total)
        print(&quot;{}: {:e}&quot;.format(i, ratio))
s = PrintProbability(5)
</code></pre></blockquote>
<p>60.<strong>扑克排中的顺子</strong><br>随机从扑克牌中抽出了5张牌,判断是不是顺子,<br>决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。<br>思路：先置换特殊字符AJQK为数字，排序，然后求出大小王即0的个数，然后求出除去0之外的，数组间的数字间隔(求间隔的时候记得减去1，比如4和5的间隔为5-4-1，表示4和5是连续的数字)，同时求间隔的时候需要鉴别是否出现对。最后比较0的个数和间隔的大小即可。<br>代码如下：</p>
<blockquote>
<pre><code># -*- coding:utf-8 -*-
class Solution:
    def IsContinuous(self, numbers):
        if numbers == None or len(numbers) &lt;= 0:
            return False
        # 把A、J、Q、K转化一下
        transDict = {&apos;A&apos;: 1, &apos;J&apos;: 11, &apos;Q&apos;: 12, &apos;K&apos;: 13}
        for i in range(len(numbers)):
            if numbers[i] in transDict.keys():
                numbers[i] = transDict[numbers[i]]
        numbers = sorted(numbers)
        numberOfzero = 0
        numberOfGap = 0
        # 统计0的个数
        i = 0
        while i &lt; len(numbers) and numbers[i] == 0:
            numberOfzero += 1
            i += 1
        # 统计间隔的数目
        small = numberOfzero
        big = small + 1
        while big &lt; len(numbers):
            # 出现对子, 不可能是顺子
            if numbers[small] == numbers[big]:
                return False
            numberOfGap += numbers[big] - numbers[small] - 1
            small = big
            big += 1
        return False if numberOfGap &gt; numberOfzero else True
test = [&apos;A&apos;, 3, 2, 5, 0]
test2 = [0, 3, 1, 6, 4]
s = Solution()
print(s.IsContinuous(test))
</code></pre></blockquote>
<p>61.<strong>圆圈中最后剩下的数字</strong><br>0, 1, 2, n-1这n个数字排成一个圆环, 从数字0开始每次从这个圆圈里删除第m个数字求这个圆圈中最后剩下的一个数字<br>思路1:使用环形链表存储，每次删除第m个节点，o（mn）</p>
<p>思路2:找规律，删除第k个数字后，将剩余的数字重新映射成0～n-2上，重复上述操作，直到剩下一个数字，O（n），代码如下：</p>
<blockquote>
<pre><code>class Solution:
    def LastRemaining_Solution(self, n, m):
        if n &lt; 1 or m &lt; 1:
            return -1
        remainIndex = 0
        for i in range(1, n+1):
            remainIndex = (remainIndex + m) % i
        return remainIndex
s=Solution()
print s.LastRemaining_Solution(8,3)
</code></pre></blockquote>
<p>62.<strong>股票的最大利润</strong><br>思路：定义两个变量，最低价格，和最大收益，每次扫描股票价格，用当前的价格减去最低价格，如果收益大于最大收益，更新最大收益，同时如果当前股票价格比最低价格低，则更新最低价格，代码如下：</p>
<blockquote>
<pre><code>class Solution:
    def best_benifit(self,lists):
        if lists==None or len(lists)==0:
            return 0
        mins,maxs=lists[0],lists[0]
        for i in range(1,len(lists)):
            tmp=lists[i]-mins
            if tmp&gt;maxs:
                maxs=tmp
            if lists[i]&lt;mins:
                mins=lists[i]
        return maxs
s=Solution()
print s.best_benifit([9,11,8,5,7,12,16,14])
</code></pre></blockquote>
<p>63.<strong>求1+2+….+n</strong><br>求1+2+3+…+n，<br>要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）<br>思路：利用两个函数，一个函数充当递归函数的角色，另一个函数处理终止递归的情况。如果对n连续进行两次反运算，那么非零的n转换为True，0转换为False。利用这一特性终止递归。注意考虑测试用例为0的情况。代码如下：</p>
<blockquote>
<pre><code>class Solution:
    def Sum_Solution(self, n):
        return self.sumN(n)
    def sum0(self, n):
        return 0
    # 利用非0值作两次非运算返回false, 0作两次非运算返回True
    def sumN(self, n):
        fun = {False: self.sum0, True: self.sumN}
        # 此处的fun[not not n] 不能写作func[not not n-1], 否则测试用例为0的话, 就会无限次迭代
        return n + fun[not not n](n - 1)
    def Sum_Solution2(self, n):
        return n and self.Sum_Solution(n - 1) + n
s = Solution()
print(s.Sum_Solution(5))
</code></pre></blockquote>
<p>64.<strong>不用加减乘除做加法</strong><br>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。<br>思路：将两个数的加法看作两步，第一步是两个数相加但是不进位，第二步是记录之前的两数相加应该进位的地方加上前一个相加但是不进位的数。对于具体的两个不小于0的数m和n，第一步可以看做m和n的异或运算m^n，第二步可以看做m和n的与运算然后左移一位得到实际的进位位置(m&amp;n)&lt;&lt;1。然后把两个得到的数字加起来继续操作，指到carry进位为0终止操作，代码如下：</p>
<blockquote>
<pre><code>class Solution:
    def Add(self, num1, num2):
        while num2:
            sum = num1 ^ num2
            carry = (num1 &amp; num2) &lt;&lt; 1
            num1 = sum
            num2 = carry
        return num1
s = Solution()
print(s.Add(4, 2))
</code></pre></blockquote>
<p>65.<strong>构建乘积数组</strong><br>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1]<br>其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。</p>
<blockquote>
<pre><code># -*- coding:utf-8 -*-
class Solution:
    def multiply(self, A):
        if A == None or len(A) &lt;= 0:
            return
        length = len(A)
        aList = [1] * length
        for i in range(1, length):
            aList[i] = aList[i-1] * A[i-1]
        temp = 1
        for i in range(length-2, -1, -1):
            temp = temp * A[i+1]
            aList[i] *= temp
        return aList
test = [1, 2, 3, 4]
s = Solution()
print(s.multiply(test))
</code></pre></blockquote>
<p>66.<strong>把字符串转换为整数</strong><br>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数</p>
<pre><code># -*- coding:utf-8 -*-
class Solution:
    # 如果输出是0, 通过检查flag判断输入不合法还是输入直接是&apos;0&apos;
    def StrToInt(self, s):
        flag = False
        if s == None or len(s) &lt; 1:
            return 0
        numStack = []
        dict = {&apos;0&apos;: 0, &apos;1&apos;: 1, &apos;2&apos;: 2, &apos;3&apos;: 3, &apos;4&apos;: 4, &apos;5&apos;: 5, &apos;6&apos;: 6, &apos;7&apos;: 7, &apos;8&apos;: 8, &apos;9&apos;: 9}
        for i in s:
            if i in dict.keys():
                numStack.append(dict[i])
            elif i == &apos;+&apos;:
                continue
            elif i == &apos;-&apos;:
                continue
            else:
                return 0
        print(numStack)
        ans = 0
        if len(numStack) == 1 and numStack[0] == 0:
            flag = True
            return 0
        for i in numStack:
            ans = ans*10 + i
        if s[0] == &apos;-&apos;:
            ans = 0 - ans
        return ans
test = &apos;-123-56&apos;
s = Solution()
print(s.StrToInt(test))
</code></pre><p>65.<strong>二叉树的最低公共祖先</strong><br>代码如下：</p>
<blockquote>
<pre><code>class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
class Solution:
    &quot;&quot;&quot;
    @param root: The root of the binary search tree.
    @param A and B: two nodes in a Binary.
    @return: Return the least common ancestor(LCA) of the two nodes.
    &quot;&quot;&quot;
    def lowestCommonAncestor(self, root, A, B):
        # write your code here
        if root == None:
            return False
        pathA = self.storeNodes(root, A)[0]
        pathB = self.storeNodes(root, B)[0]
        if pathA and pathB:
            lenA, lenB = len(pathA), len(pathB)
            diff = abs(lenA - lenB)
            if lenA &gt; lenB:
                markA = lenA - diff - 1
                markB = lenB - 1
            else:
                markA = lenA - 1
                markB = lenB - diff - 1
            while markA &gt;= 0 and markB &gt;= 0:
                if pathA[markA] == pathB[markB]:
                    return pathA[markA]
                markA -= 1
                markB -= 1
    def storeNodes(self, root, targetNode):
        if root == None or targetNode == None:
            return []
        elif root.val == targetNode.val:
            return [[targetNode]]
        stack = []
        if root.left:
            stackLeft = self.storeNodes(root.left, targetNode)
            for i in stackLeft:
                i.insert(0, root)
                stack.append(i)
        if root.right:
            stackRight = self.storeNodes(root.right, targetNode)
            for i in stackRight:
                i.insert(0, root)
                stack.append(i)
        return stack
</code></pre></blockquote>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/算法/">算法</a>
</div>


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/10/17/实现一个包含insert、search、和startWith的前缀树/" title="实现一个包含insert、search、和startWith的前缀树" itemprop="url">实现一个包含insert、search、和startWith的前缀树</a>
  </h1>
  <p class="article-author">By
       
		<a href="/" title="Liberty_zheng" target="_blank" itemprop="author">Liberty_zheng</a>
		
  <p class="article-time">
    <time datetime="2017-10-17T07:39:49.000Z" itemprop="datePublished"> Published 2017-10-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Tri树，又称为词典树，单词查找树活着前缀树，是一种用于快速检索的多叉树结构，insert、search、和startWith方法实现代码如下：</p>
<blockquote>
<pre><code>class TrieNode(object):   #节点结构
    def __init__(self):
        self.children = {}
        self.IsWord = False
class Trie(object):       #树结构
    def __init__(self):
        self.root = TrieNode()
    def insert(self, word):   #插入方法
        node = self.root
        for letter in word:
            child = node.children.get(letter)
            if child is None:
                child = TrieNode()
                node.children[letter] = child
            node = child
        node.IsWord = True
    def search(self, word):  #查询方法
        node = self.root
        for letter in word:
            node = node.children.get(letter)
            if node is None:
                return False
        return node.IsWord
    def startsWith(self, prefix):   #是否含有以prefix开头的方法
        node = self.root
        for letter in prefix:
            node = node.children.get(letter)
            if node is None:
                return False
        return True
</code></pre></blockquote>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/算法/">算法</a>
</div>


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/10/17/常用八大排序算法/" title="常用八大排序算法" itemprop="url">常用八大排序算法</a>
  </h1>
  <p class="article-author">By
       
		<a href="/" title="Liberty_zheng" target="_blank" itemprop="author">Liberty_zheng</a>
		
  <p class="article-time">
    <time datetime="2017-10-17T03:07:13.000Z" itemprop="datePublished"> Published 2017-10-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>排序分为内部排序和外部排序，内部排序是数据在内存中进行，而数据比较大排序的时候，内存有限，需要访问外存，采用外部排序。我们常说的八大排序算法一般是指内部排序。<br>排序分类如下图所示</p>
<p><center><img width="500" align="center" src="/2017/10/17/常用八大排序算法/sort.png"></center></p>
<p><center>排序分类</center><br>有上图可知常用内部排序算法有直接插入排序、希尔排序、简单选择排序、堆排序、冒泡排序、快速排序、归并排序和基数排序<br>各排序算法思想和代码如下</p>
<ol>
<li>快速排序<br><strong>思想：</strong>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。代码如下：<blockquote>
<pre><code>def quick_sort(lists, left, right):
 if left &gt;= right:
     return lists
 key = lists[left]
 low = left
 high = right
 while left &lt; right:
     while left &lt; right and lists[right] &gt;= key:
         right -= 1
     lists[left] = lists[right]
     while left &lt; right and lists[left] &lt;= key:
         left += 1
     lists[right] = lists[left]
 lists[right] = key
 quick_sort(lists, low, left - 1)
 quick_sort(lists, left + 1, high)
 return lists
</code></pre></blockquote>
</li>
<li>插入排序<br><strong>思想：</strong>插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。代码如下：<blockquote>
<pre><code>def insert_sort(lists):
 count = len(lists)
 for i in range(1, count):
     key = lists[i]
     j = i - 1
     while j &gt;= 0:
         if lists[j] &gt; key:
             lists[j + 1] = lists[j]
             lists[j] = key
         j -= 1
 return lists
</code></pre></blockquote>
</li>
<li>希尔排序<br><strong>思想：</strong>希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。代码如下：<blockquote>
<pre><code>def shell_sort(lists):
 count = len(lists)
 step = 2
 group = count / step
 while group &gt; 0:
     for i in range(0, group):
         j = i + group
         while j &lt; count:
             k = j - group
             key = lists[j]
             while k &gt;= 0:
                 if lists[k] &gt; key:
                     lists[k + group] = lists[k]
                     lists[k] = key
                 k -= group
             j += group
        group /= step
 return lists
</code></pre></blockquote>
</li>
<li>冒泡排序<br><strong>思想：</strong>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。代码如下：<blockquote>
<pre><code>def bubble_sort(lists):
 count = len(lists)
 for i in range(0, count):
     for j in range(i + 1, count):
         if lists[i] &gt; lists[j]:
             lists[i], lists[j] = lists[j], lists[i]
 return lists
</code></pre></blockquote>
</li>
<li>直接选择排序<br><strong>思想：</strong>第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。代码如下：<blockquote>
<pre><code>def select_sort(lists):
 count = len(lists)
 for i in range(0, count):
     min = i
     for j in range(i + 1, count):
         if lists[min] &gt; lists[j]:
             min = j
     lists[min], lists[i] = lists[i], lists[min]
 return lists
</code></pre></blockquote>
</li>
<li>堆排序<br><strong>思想：</strong>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。代码如下：<blockquote>
<pre><code>def adjust_heap(lists, i, size):
 lchild = 2 * i + 1
 rchild = 2 * i + 2
 max = i
 if i &lt; size / 2:
     if lchild &lt; size and lists[lchild] &gt; lists[max]:
         max = lchild
     if rchild &lt; size and lists[rchild] &gt; lists[max]:
         max = rchild
     if max != i:
         lists[max], lists[i] = lists[i], lists[max]
         adjust_heap(lists, max, size)
def build_heap(lists, size):
 for i in range(0, (size/2))[::-1]:
     adjust_heap(lists, i, size)
def heap_sort(lists):
 size = len(lists)
 build_heap(lists, size)
 for i in range(0, size)[::-1]:
     lists[0], lists[i] = lists[i], lists[0]
     adjust_heap(lists, 0, i)
</code></pre></blockquote>
</li>
<li><p>归并排序<br><strong>思想：</strong>比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。代码如下：</p>
<blockquote>
<pre><code>def merge(a, b):
 c = []
 h = j = 0
 while j &lt; len(a) and h &lt; len(b):
     if a[j] &lt; b[h]:
         c.append(a[j])
         j += 1
     else:
         c.append(b[h])
         h += 1
 if j == len(a):
     for i in b[h:]:
         c.append(i)
 else:
     for i in a[j:]:
         c.append(i)
 return c
def merge_sort(lists):
 if len(lists) &lt;= 1:
     return lists
 mid = len(lists)/2
 left = merge_sort(lists[:mid])
 right = merge_sort(lists[mid:])
 return merge(left, right)
print merge_sort([1,3,2,6,4,9,7,8,11,23])
</code></pre></blockquote>
</li>
<li><p>基数排序<br><strong>思想：</strong>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序     法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。代码如下：</p>
<blockquote>
<pre><code>import math
def radix_sort(lists, radix=10):
     k = int(math.ceil(math.log(max(lists), radix)))
     bucket = [[] for i in range(radix)]
     for i in range(1, k+1):
         for j in lists:
             bucket[j/(radix**(i-1)) % (radix**i)].append(j)
         del lists[:]
         for z in bucket:
             lists += z
             del z[:]
     return lists    
</code></pre></blockquote>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/算法/">算法</a>
</div>


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/10/17/长度为n的数组选取k个数据所有组合/" title="长度为n的数组选取k个数据所有组合" itemprop="url">长度为n的数组选取k个数据所有组合</a>
  </h1>
  <p class="article-author">By
       
		<a href="/" title="Liberty_zheng" target="_blank" itemprop="author">Liberty_zheng</a>
		
  <p class="article-time">
    <time datetime="2017-10-17T02:44:19.000Z" itemprop="datePublished"> Published 2017-10-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>一个长度为n的数组或字符串，打印选取k个数据所组成的可能性(不要求排列循序，如123和132为一种可能性)</p>
<p><strong>思路：</strong><br>由于k的值不确定，有可能很大，如果采用k层循环的话，时间复杂度会非常大。采取先固定前k-1位，从后面选取一位组合，从前向后递归<br>代码如下</p>
<blockquote>
<pre><code>ans=[]
Count = 0
def combination(data, t, vl):
    _kk = len(data)
    for _i in range(_kk - t + 1):
        vl.append(data[_i])
        new_data = data[_i + 1:]
        if t - 1 == 1:
            for _j in range(len(new_data)):
                ans.append(&apos;&apos;.join(map(str, vl)) + str(new_data[_j]))
                global Count
                Count += 1
        else:
            combination(new_data, t - 1, vl)
        vl.pop()
    return ans
if __name__ == &apos;__main__&apos;:
    n = input()  # 总数
    k = input()  # 选取个数
    vl = []  # 用于存放选中的数字
    data = range(1, n + 1)  # [1, 2, 3, 4,..n]
    result=combination(data, k, vl)
    print result
</code></pre></blockquote>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/算法/">算法</a>
</div>


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/10/17/牛牛最多需要尝试多少次密码/" title="牛牛最多需要尝试多少次密码" itemprop="url">牛牛最多需要尝试多少次密码</a>
  </h1>
  <p class="article-author">By
       
		<a href="/" title="Liberty_zheng" target="_blank" itemprop="author">Liberty_zheng</a>
		
  <p class="article-time">
    <time datetime="2017-10-17T00:50:17.000Z" itemprop="datePublished"> Published 2017-10-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>牛牛变得黑化了,想要摧毁掉地球。但他忘记了开启地球毁灭器的密码。牛牛手里有一个字符串S,牛牛还记得从S中去掉一个字符就恰好是正确的密码,请你帮牛牛求出他最多需要尝试多少次密码。<br>如样例所示S = “ABA”,3个可能的密码是”BA”, “AA”, “AB”.<br>当S = “A”, 牛牛唯一可以尝试的密码是一个空的密码,所以输出1. </p>
<p><strong>思路：</strong><br>如果没有相邻的重复字母，次数即为字符串的长度，每有一对相邻重复字母，就会重复一次，次数因此减一<br>代码如下：</p>
<blockquote>
<pre><code>data=raw_input()
count=len(data)
for i in range(1,len(data)):
    if data[i]==data[i-1]:
        count-=1
print count
</code></pre></blockquote>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/算法/">算法</a>
</div>


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/机器学习/" title="机器学习">机器学习<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/爬虫/" title="爬虫">爬虫<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>25</sup></a></li>
		  
		
		</ul>
</div>


  

  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Cassiel in BISTU. <br/>
			</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="Liberty_zheng">Liberty_zheng</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
