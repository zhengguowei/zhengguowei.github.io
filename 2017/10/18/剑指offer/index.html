
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>剑指offer | Cindy</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Liberty_zheng">
    

    
    <meta name="description" content="1.二维数组的查找在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。思路：首先选取右上角的数字，如果相等，返回查找结果，结束查找，如果该数字大于查找的数字，则剔除该列，如果数字小于要查找数字，则剔除该行，这样每次都可以在数组的查找范围中剔除一行或一列。代码如下：  def searc">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer">
<meta property="og:url" content="http://yoursite.com/2017/10/18/剑指offer/index.html">
<meta property="og:site_name" content="Cindy">
<meta property="og:description" content="1.二维数组的查找在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。思路：首先选取右上角的数字，如果相等，返回查找结果，结束查找，如果该数字大于查找的数字，则剔除该列，如果数字小于要查找数字，则剔除该行，这样每次都可以在数组的查找范围中剔除一行或一列。代码如下：  def searc">
<meta property="og:updated_time" content="2017-10-29T10:58:14.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="剑指offer">
<meta name="twitter:description" content="1.二维数组的查找在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。思路：首先选取右上角的数字，如果相等，返回查找结果，结束查找，如果该数字大于查找的数字，则剔除该列，如果数字小于要查找数字，则剔除该行，这样每次都可以在数组的查找范围中剔除一行或一列。代码如下：  def searc">

    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Cindy" title="Cindy"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Cindy">Cindy</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/10/18/剑指offer/" title="剑指offer" itemprop="url">剑指offer</a>
  </h1>
  <p class="article-author">By
       
		<a href="/" title="Liberty_zheng" target="_blank" itemprop="author">Liberty_zheng</a>
		
  <p class="article-time">
    <time datetime="2017-10-18T00:07:58.000Z" itemprop="datePublished"> Published 2017-10-18</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		
			
		
		</div>
		
		<p>1.<strong>二维数组的查找</strong><br>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br>思路：首先选取右上角的数字，如果相等，返回查找结果，结束查找，如果该数字大于查找的数字，则剔除该列，如果数字小于要查找数字，则剔除该行，这样每次都可以在数组的查找范围中剔除一行或一列。<br>代码如下：</p>
<blockquote>
<pre><code>def search(arr,n):
     i,j=0,len(arr[0])-1
    while i&lt;len(arr) and j&gt;0:
        if n==arr[i][j]:
            return True
        elif n&gt;arr[i][j]:
            i+=1
        else:
            j-=1
    return False
</code></pre></blockquote>
<p>当然也有效率不高的每行查找，代码如下：</p>
<blockquote>
<pre><code>def search(arr,n):
    for x in arr:
         if n in x:
             return True
     return False
</code></pre></blockquote>
<p>2.<strong>替换空格</strong><br>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br>有如下三个思路：</p>
<p>思路一：创建新的字符串进行替换</p>
<blockquote>
<pre><code>def replaceSpace1(self, s):
    tempstr = &apos;&apos;
    if type(s) != str:
        return
    for c in s:
        if c == &apos; &apos;:
            tempstr += &apos;%20&apos;
        else:
            tempstr += c
    return tempstr
</code></pre></blockquote>
<p>思路二：简单代码替换，在Python中str类型是不可变的类型, 使用replace语句会生成一个新的str, 原始的s还是带空格的str变量</p>
<blockquote>
<pre><code>def replaceSpace2(self, s):
    if type(s) != str:
        return
    return s.replace(&apos; &apos;, &apos;%20&apos;)
</code></pre></blockquote>
<p>思路三：统计空格的个数，将字符串拉长，每多一个空格字符串长度增加2，从后向前，将子串已到相对应的位置</p>
<blockquote>
<pre><code>def replaceSpace3(self, s): # 判断输入类型的时候，isinstance必须首先判断，因为如果输入为integer的话，没有len，就会直接报错
    if not isinstance(s,str) or len(s) &lt;= 0 or s == None:
        return &quot;&quot;
    spaceNum = 0
    for i in s:
        if i == &quot; &quot;:
            spaceNum += 1
    newStrLen = len(s) + spaceNum * 2
    newStr = newStrLen * [None]
    indexOfOriginal, indexOfNew = len(s) - 1, newStrLen - 1
    while indexOfNew &gt;= 0 and indexOfNew &gt;= indexOfOriginal:
        if s[indexOfOriginal] == &apos; &apos;:
            newStr[indexOfNew-2:indexOfNew+1] = [&apos;%&apos;, &apos;2&apos;, &apos;0&apos;]
            indexOfNew -= 3
            indexOfOriginal -= 1
        else:
            newStr[indexOfNew] = s[indexOfOriginal]
            indexOfNew -= 1
            indexOfOriginal -= 1
    return &quot;&quot;.join(newStr)
s = &apos;we are happy&apos;
test = Solution()
print(test.replaceSpace1(s))
print(test.replaceSpace2(s))
print(test.replaceSpace3(s))
</code></pre></blockquote>
<p>3.<strong>从尾到头打印链表</strong><br>输入一个链表，从尾到头打印链表每个节点的值。<br>思路1：定义一个栈，将链表遍历，将节点数值存入栈中，然后依次出栈<br>代码如下：</p>
<blockquote>
<pre><code>class ListNode:
    def __init__(self, x=None):
        self.val = x
        self.next = None    
class Solution:
    def printListFromTailToHead(self, listNode):
        if listNode.val == None:
            return
        l = []
        head = listNode
        while head:
            l.insert(0, head.val)
            head = head.next
        return l
node1 = ListNode(10)
node2 = ListNode(11)
node3 = ListNode(13)
node1.next = node2
node2.next = node3
S = Solution()
print(S.printListFromTailToHead(node1))
</code></pre></blockquote>
<p>思路2:使用递归，打印当前节点的下一个节点的数值<br>代码如下：</p>
<blockquote>
<pre><code>def printListFromTailToHead1(listNode):
    if listNode!=None:
        if listNode.next!=None:
            printListFromTailToHead1(listNode.next)
        print listNode.val
</code></pre></blockquote>
<p>4.<strong>重建二叉树</strong><br>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<br>思路:先序遍历的第一个值为根节点，找在中序遍历中找到该节点的下标，该节点将树分为左右子树，递归的进行建树<br>代码如下：</p>
<blockquote>
<pre><code>class Node:
    def __init__(self, data, left, right):
        self.data=data
        self.left=left
        self.right=right
def construct_tree(preorder,midorder):
    if len(preorder)==0:
        return None
    root_data=preorder[0]
    i=midorder.index(root_data)
    left=construct_tree(preorder[1:i+1],midorder[:i])
    right=construct_tree(preorder[i+1:],midorder[i+1:])
    return Node(root_data,left,right)
if __name__==&apos;__main__&apos;:
    pre_order = [1, 2, 4, 7, 3, 5, 6, 8]
    mid_order = [4, 7, 2, 1, 5, 3, 8, 6]
    root=construct_tree(pre_order,mid_order)
    print root
</code></pre></blockquote>
<p>5.<strong>用两个栈实现队列</strong><br>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<br>思路：定义两个队列，stack1和stack2，如果push，则将数据存入stack1，如果pop，如果stack2中有数据，则直接弹出，否则先将stack1中数据依次弹出存入stack2中，再弹出stack2一个数据。<br>代码如下：</p>
<blockquote>
<pre><code>class Solution:
    def __init__(self):
        self.stack1=[]
        self.stack2=[]
    def push(self, node):
        self.stack1.append(node)
    def pop(self):
        if self.stack2==[]:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        return self.stack2.pop()
</code></pre></blockquote>
<p>6.<strong>二叉树的下一个结点</strong><br>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<blockquote>
<pre><code>class Solution2:
def GetNext(self, pNode):
    # 输入是一个空节点
    if pNode == None:
        return None
    # 注意当前节点是根节点的情况。所以在最开始设定pNext = None, 如果下列情况都不满足, 说明当前结点为根节点, 直接输出None
    pNext = None
    # 如果输入节点有右子树，则下一个结点是当前节点右子树中最左节点
    if pNode.right:
        pNode = pNode.right
        while pNode.left:
            pNode = pNode.left
        pNext = pNode
    else:
        # 如果当前节点有父节点且当前节点是父节点的左子节点, 下一个结点即为父节点
        if pNode.next and pNode.next.left == pNode:
            pNext = pNode.next
        # 如果当前节点有父节点且当前节点是父节点的右子节点, 那么向上遍历
        # 当遍历到当前节点为父节点的左子节点时, 输入节点的下一个结点为当前节点的父节点
        elif pNode.next and pNode.next.right == pNode:
            pNode = pNode.next
            while pNode.next and pNode.next.right == pNode:
                pNode = pNode.next
            # 遍历终止时当前节点有父节点, 说明当前节点是父节点的左子节点, 输入节点的下一个结点为当前节点的父节点
            # 反之终止时当前节点没有父节点, 说明当前节点在位于根节点的右子树, 没有下一个结点
            if pNode.next:
                pNext = pNode.next
    return pNext
</code></pre></blockquote>
<p>7.<strong>斐波那契数列</strong><br>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。<br>思路1:采用循环，时间复杂度为O(n），代码如下：</p>
<blockquote>
<pre><code>def fabci(n):
    if n==0:
        return 0
    a=0
    b=1
    for i in range(n-1):
        a,b=b,a+b
    return b
</code></pre></blockquote>
<p>思路2：采用递归，复杂度较高，会重复计算相同的值<br>代码如下：</p>
<blockquote>
<pre><code>def fab(n):
      if n==1:
        return 1
      if n==0:
        return 0
      else:
        result=int(fab(n-1))+int(fab(n-2))    
    return result
</code></pre></blockquote>
<p>青蛙跳台阶, 每次可以跳1级或2级<br>思路：其实就是斐波那契数列问题，每次可以跳1级或者两级，则下次的可能性为前两次可能性之和</p>
<blockquote>
<pre><code>def jumpFloor(self, number):
 # write code here
 tempArray = [1, 2]
 if number &gt;= 3:
     for i in range(3, number + 1):
         tempArray[(i + 1) % 2] = tempArray[0] + tempArray[1]
 return tempArray[(number + 1) % 2]
</code></pre></blockquote>
<p>8.<strong>旋转数组的最小数字</strong><br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。给出的所有元素都大于0，若数组大小为0，请返回0。<br>思路：如果遍历一遍，复杂度太高，可以采用二分查找，用两个指针分别指向第一个值和最后一个值，取中间的数，如果该数小于最前面的数，则该数在后面递增的数组里，将前面的指针指向该数，否则在前面递增的数组里，将后面的指针指向该数，将更新后的数组重复做以上操作，当两个指针距离是1时结束，返回后面的指针指向的数字。代码如下：</p>
<blockquote>
<pre><code>def minNumberInRotateArray2(rotateArray):
if len(rotateArray) == 0:
    return 0
front, rear = 0, len(rotateArray) - 1
midIndex = 0  #如果数组把前0个数移到后面，则直接返回第一个
while rotateArray[front] &gt;= rotateArray[rear]:
    if rear - front == 1:
        midIndex = rear
        break
    midIndex = (front + rear) // 2
    if rotateArray[front] == rotateArray[rear] and rotateArray[front] == rotateArray[midIndex]:
        return MinInOrder(rotateArray, front, rear)
    if rotateArray[midIndex] &gt;= rotateArray[front]:
        front = midIndex
    elif rotateArray[midIndex] &lt;= rotateArray[rear]:
        rear = midIndex
return rotateArray[midIndex]
def MinInOrder( array, front, end):
    result = array[0]
    for i in array[front:end + 1]:
        if i &lt; result:
            result = i
    return result
print minNumberInRotateArray2([3,4,5,1,2])
</code></pre></blockquote>
<p>9.矩阵中的路径<br>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。例如 [[a b c e], [s f c s], [a d e e]]矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。<br>思路：递归的采用回溯法</p>
<blockquote>
<pre><code>class Solution:
def hasPath(self, matrix, rows, cols, path):
    if matrix == None or rows &lt; 1 or cols &lt; 1 or path == None:
        return False
    visited = [0] * (rows * cols)
    pathLength = 0
    for row in range(rows):
        for col in range(cols):
            if self.hasPathCore(matrix, rows, cols, row, col, path, pathLength, visited):
                return True
    return False
def hasPathCore(self, matrix, rows, cols, row, col, path, pathLength, visited):
    if len(path) == pathLength:
        return True
    hasPath = False
    if row &gt;= 0 and row &lt; rows and col &gt;= 0 and col &lt; cols and matrix[row * cols + col] == path[pathLength] and not \
    visited[row * cols + col]:
        pathLength += 1
        visited[row * cols + col] = True
        hasPath = self.hasPathCore(matrix, rows, cols, row, col - 1, path, pathLength, visited) or \
                  self.hasPathCore(matrix, rows, cols, row - 1, col, path, pathLength, visited) or \
                  self.hasPathCore(matrix, rows, cols, row, col + 1, path, pathLength, visited) or \
                  self.hasPathCore(matrix, rows, cols, row + 1, col, path, pathLength, visited)
        if not hasPath:
            pathLength -= 1
            visited[row * cols + col] = False
    return hasPath
</code></pre></blockquote>
<p>10.<strong>机器人的运动范围</strong><br>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？<br>思路：机器人从（0，0）开始运动，当它准备进入为（i，j）位置时，判断坐标要求能否进入，如果可以进入，然后递归的进入它相邻的4个格子（i,j-1）,（i-1,j）（i,j+1）,（i+1,j）,采用回溯法，代码如下：</p>
<blockquote>
<pre><code>class Solution:
    def movingCount(self, threshold, rows, cols):
        visited = [False] * (rows * cols)
        count = self.movingCountCore(threshold, rows, cols, 0, 0, visited)
        return count
    def movingCountCore(self, threshold, rows, cols, row, col, visited):
        count = 0
        if self.check(threshold, rows, cols, row, col, visited):
            visited[row * cols + col] = True
            count = 1 + self.movingCountCore(threshold, rows, cols, row-1, col, visited) + \
                        self.movingCountCore(threshold, rows, cols, row+1, col, visited) + \
                        self.movingCountCore(threshold, rows, cols, row, col-1, visited) + \
                        self.movingCountCore(threshold, rows, cols, row, col+1, visited)
        return count
    def check(self, threshold, rows, cols, row, col, visited):
        if row &gt;= 0 and row &lt; rows and col &gt;= 0 and col &lt; cols and self.getDigitSum(row) + self.getDigitSum(col) &lt;= threshold and not visited[row * cols + col]:
            return True
        return False
    def getDigitSum(self, number):
        sum = 0
        while number &gt; 0:
            sum += (number % 10)
            number = number // 10
        return sum
s = Solution()
print(s.movingCount(5, 10, 10))
</code></pre></blockquote>
<p>11.<strong>剪绳子</strong><br>给你一根长度为n的绳子，请把绳子剪成m段 (m和n都是整数，n&gt;1并且m&gt;1)每段绳子的长度记为k[0],k[1],…,k[m].请问k[0]<em>k[1]</em>…<em>k[m]可能的最大乘积是多少？例如，当绳子的长度为8时，我们把它剪成长度分别为2,3,3的三段，此时得到的最大乘积是18.<br>思路1：首先定义函数f(n)为把长度为n的绳子剪成若干段后各段长度乘积的最大值。在剪第一刀时，我们有n-1种选择，也就是说第一段绳子的可能长度分别为1,2,3…..，n-1。因此f(n)=max(f(i)</em>f(n-i))，其中0&lt;i&lt;n。这是一个自上而下的递归公式。由于递归会有大量的不必要的重复计算。一个更好的办法是按照从下而上的顺序计算，也就是说我们先得到f(2),f(3)，再得到f(4),f(5)，直到得到f(n)。当绳子的长度为2的时候，只能剪成长度为1的两段，所以f(2) = 1，当n = 3时，容易得出f(3) = 2;代码如下：</p>
<blockquote>
<pre><code> public class Main {
public static void main(String[] args) {
    System.out.println(maxAfterCutting(8));
}
/**
 * 常规的需要O(n2)的时间复杂度和O(n)的空间复杂度的动态规划思路 题目的意思是:绳子至少是2米，并且必须最少剪一刀。
 */
public static int maxAfterCutting(int length) {
    if (length &lt; 2)
        return 0;
    if (length == 2)
        return 1;
    if (length == 3)
        return 2;
    // 子问题的最优解存储在f数组中，数组中的第i个元素表示把长度为i的绳子剪成若干段后各段长度乘积的最大值。
    int[] f = new int[length + 1];
    f[0] = 0;
    f[1] = 1;
    f[2] = 2;
    f[3] = 3;
    int result = 0;
    for (int i = 4; i &lt;= length; i++) {
        int max = 0;
        for (int j = 1; j &lt;= i / 2; j++) {
            int num = f[j] * f[i - j];
            if (max &lt; num)
                max = num;
        }
        f[i] = max;
    }
    result = f[length];
    return result;
}
</code></pre><p>}</p>
</blockquote>
<p>思路2:贪婪算法，当n&gt;=5时尽可能多的剪长度为3的绳子，剩下剩下的绳子为4时，把绳子剪成两个长度为2的绳子<br>代码如下：</p>
<blockquote>
<pre><code>def long_cut(n):
    if n==3:
        return 2
    if n==2:
        return 1
    if n==0:
        return 0
    counts=0
    for i in range(1,n+1):
        if i%3==0:
            counts+=1
    rest=n-counts*3
    if rest==1:
        return pow(3,counts-1)*4
    elif rest==2:
        return pow(3,counts)*2
    else:
        return pow(3,counts)
    print long_cut(0)
</code></pre></blockquote>
<p>12.<strong>二进制中1的个数</strong><br>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。<br>思路1：先判断整数二进制表示中最右面一位是不是1，接着把输入的整数右移一位，如此反复，直到整数为0<br>代码如下：</p>
<blockquote>
<pre><code>def one_num(n):
counts=0
while n!=0:
    if n&amp;1==1:
        counts+=1
    n=n&gt;&gt;1
return  counts
</code></pre></blockquote>
<p>思路2:调用系统函数，代码如下：</p>
<blockquote>
<pre><code>print bin(n).count(&apos;1&apos;)
</code></pre></blockquote>
<p>思路3:把一个数和该数减一的数做与运算，有多少位1，进行多少次运算，如1100和1011与运算得到1000，代码如下：</p>
<blockquote>
<pre><code>def get_one(n):
    counts=0
    while n!=0:
        counts+=1
        n=n&amp;(n-1)
    return counts
</code></pre></blockquote>
<p>拓展：判断一个数是不是2得整数次幂，代码如下：</p>
<blockquote>
<pre><code>def powerOf2(self, n):
    if n&amp;(n-1) == 0:
        return True
    else:
        return False
</code></pre></blockquote>
<p>拓展：判断两个数的二进制表示有多少位不一样, 直接比较两个数的二进制异或就可以 </p>
<blockquote>
<pre><code>def andOr( m, n):
    diff = m ^ n
    count = 0
    while diff:
        count += 1
        diff = diff &amp; (diff - 1)
    return count
</code></pre></blockquote>
<p>13.<strong>数值的整数次方</strong><br>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br>思路：<br>需要注意的地方:<br>当指数为负数的时候<br>当底数为零切指数为负数的情况<br>在判断底数base是不是等于0的时候,不能直接写base==0, 因为计算机内表示小数时有误差,只能判断他们的差的绝对值是不是在一个很小的范围内<br>当n为偶数, a^n = a^(n/2) <em> a^(n/2)<br>当n为奇数, a^n = a^((n-1)/2) </em> a^((n-1)/2)) * a<br>利用右移一位运算代替除以2<br>利用位与运算代替了求余运算法%来判断一个数是奇数还是偶数<br>优化代码速度<br>代码如下：</p>
<blockquote>
<pre><code>def Power( base, exponent):
    if exponent == 0:
        return 1
    if exponent == 1:
        return base
    if exponent == -1:
        return 1 / base
    result = Power(base, exponent &gt;&gt; 1)
    result *= result
    if (exponent &amp; 0x1) == 1:
        result *= base
    return result
</code></pre></blockquote>
<p>14.<strong>打印从1到最大的n位整数</strong><br>输入数字n, 按顺序打印从1最大的n位十进制数<br>比如输入3, 则打印出1、2、3、到最大的3位数即999<br>思路：用字符串来存储数字</p>
<blockquote>
<pre><code>public class Main {
public static void Print1ToMaxOfNDigits_2(int n) {
    if (n &lt;= 0) {
        return;
    }
    StringBuffer number = new StringBuffer();
    for (int i = 0; i &lt; n; i++) {
        number.append(&apos;0&apos;);
    }
    while (!Increment(number)) {
        PrintNumber(number);
    }
}
public static boolean Increment(StringBuffer s) {
    boolean isOverflow = false;
    int nTakeOver = 0;
    int nLength = s.length();
    for (int i = nLength - 1; i &gt;= 0; i--) {
        int nSum = s.charAt(i) - &apos;0&apos; + nTakeOver;
        if (i == nLength - 1) {
            nSum++;
        }
        if (nSum &gt;= 10) {
            if (i == 0) {
                isOverflow = true;
            } else {
                nSum -= 10;
                nTakeOver = 1;
                s.setCharAt(i, (char) (&apos;0&apos; + nSum));
            }
        } else {
            s.setCharAt(i, (char) (&apos;0&apos; + nSum));
            break;
        }
    }
    return isOverflow;
}
public static void PrintNumber(StringBuffer s) {
    boolean isBeginning0 = true;
    for (int i = 0; i &lt; s.length(); i++) {
        if (isBeginning0 &amp;&amp; s.charAt(i) != &apos;0&apos;) {
            isBeginning0 = false;
        }
        if (!isBeginning0) {
            System.out.print(s.charAt(i));
        }
    }
    System.out.println();
}
public static void main(String[] args) {
    Print1ToMaxOfNDigits_2(2);
}
</code></pre><p>}</p>
</blockquote>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/算法/">算法</a>
</div>


</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yoursite.com/2017/10/18/剑指offer/" data-title="剑指offer | Cindy" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2017/10/18/N皇后问题/" title="N皇后问题">
  <strong>上一篇：</strong><br/>
  <span>
  N皇后问题</span>
</a>
</div>


<div class="next">
<a href="/2017/10/17/实现一个包含insert、search、和startWith的前缀树/"  title="实现一个包含insert、search、和startWith的前缀树">
 <strong>下一篇：</strong><br/> 
 <span>实现一个包含insert、search、和startWith的前缀树
</span>
</a>
</div>

</nav>

	


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/机器学习/" title="机器学习">机器学习<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/爬虫/" title="爬虫">爬虫<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>24</sup></a></li>
		  
		
		</ul>
</div>


  

  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Cassiel in BISTU. <br/>
			</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="Liberty_zheng">Liberty_zheng</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>









<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
