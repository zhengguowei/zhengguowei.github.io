
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>剑指offer | Cindy</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Liberty_zheng">
    

    
    <meta name="description" content="1.二维数组的查找在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。思路：首先选取右上角的数字，如果相等，返回查找结果，结束查找，如果该数字大于查找的数字，则剔除该列，如果数字小于要查找数字，则剔除该行，这样每次都可以在数组的查找范围中剔除一行或一列。代码如下：  def searc">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer">
<meta property="og:url" content="http://yoursite.com/2017/10/18/剑指offer/index.html">
<meta property="og:site_name" content="Cindy">
<meta property="og:description" content="1.二维数组的查找在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。思路：首先选取右上角的数字，如果相等，返回查找结果，结束查找，如果该数字大于查找的数字，则剔除该列，如果数字小于要查找数字，则剔除该行，这样每次都可以在数组的查找范围中剔除一行或一列。代码如下：  def searc">
<meta property="og:updated_time" content="2017-11-01T03:52:09.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="剑指offer">
<meta name="twitter:description" content="1.二维数组的查找在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。思路：首先选取右上角的数字，如果相等，返回查找结果，结束查找，如果该数字大于查找的数字，则剔除该列，如果数字小于要查找数字，则剔除该行，这样每次都可以在数组的查找范围中剔除一行或一列。代码如下：  def searc">

    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Cindy" title="Cindy"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Cindy">Cindy</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/10/18/剑指offer/" title="剑指offer" itemprop="url">剑指offer</a>
  </h1>
  <p class="article-author">By
       
		<a href="/" title="Liberty_zheng" target="_blank" itemprop="author">Liberty_zheng</a>
		
  <p class="article-time">
    <time datetime="2017-10-18T00:07:58.000Z" itemprop="datePublished"> Published 2017-10-18</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		
			
		
		</div>
		
		<p>1.<strong>二维数组的查找</strong><br>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br>思路：首先选取右上角的数字，如果相等，返回查找结果，结束查找，如果该数字大于查找的数字，则剔除该列，如果数字小于要查找数字，则剔除该行，这样每次都可以在数组的查找范围中剔除一行或一列。<br>代码如下：</p>
<blockquote>
<pre><code>def search(arr,n):
     i,j=0,len(arr[0])-1
    while i&lt;len(arr) and j&gt;0:
        if n==arr[i][j]:
            return True
        elif n&gt;arr[i][j]:
            i+=1
        else:
            j-=1
    return False
</code></pre></blockquote>
<p>当然也有效率不高的每行查找，代码如下：</p>
<blockquote>
<pre><code>def search(arr,n):
    for x in arr:
         if n in x:
             return True
     return False
</code></pre></blockquote>
<p>2.<strong>替换空格</strong><br>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br>有如下三个思路：</p>
<p>思路一：创建新的字符串进行替换</p>
<blockquote>
<pre><code>def replaceSpace1(self, s):
    tempstr = &apos;&apos;
    if type(s) != str:
        return
    for c in s:
        if c == &apos; &apos;:
            tempstr += &apos;%20&apos;
        else:
            tempstr += c
    return tempstr
</code></pre></blockquote>
<p>思路二：简单代码替换，在Python中str类型是不可变的类型, 使用replace语句会生成一个新的str, 原始的s还是带空格的str变量</p>
<blockquote>
<pre><code>def replaceSpace2(self, s):
    if type(s) != str:
        return
    return s.replace(&apos; &apos;, &apos;%20&apos;)
</code></pre></blockquote>
<p>思路三：统计空格的个数，将字符串拉长，每多一个空格字符串长度增加2，从后向前，将子串已到相对应的位置</p>
<blockquote>
<pre><code>def replaceSpace3(self, s): # 判断输入类型的时候，isinstance必须首先判断，因为如果输入为integer的话，没有len，就会直接报错
    if not isinstance(s,str) or len(s) &lt;= 0 or s == None:
        return &quot;&quot;
    spaceNum = 0
    for i in s:
        if i == &quot; &quot;:
            spaceNum += 1
    newStrLen = len(s) + spaceNum * 2
    newStr = newStrLen * [None]
    indexOfOriginal, indexOfNew = len(s) - 1, newStrLen - 1
    while indexOfNew &gt;= 0 and indexOfNew &gt;= indexOfOriginal:
        if s[indexOfOriginal] == &apos; &apos;:
            newStr[indexOfNew-2:indexOfNew+1] = [&apos;%&apos;, &apos;2&apos;, &apos;0&apos;]
            indexOfNew -= 3
            indexOfOriginal -= 1
        else:
            newStr[indexOfNew] = s[indexOfOriginal]
            indexOfNew -= 1
            indexOfOriginal -= 1
    return &quot;&quot;.join(newStr)
s = &apos;we are happy&apos;
test = Solution()
print(test.replaceSpace1(s))
print(test.replaceSpace2(s))
print(test.replaceSpace3(s))
</code></pre></blockquote>
<p>3.<strong>从尾到头打印链表</strong><br>输入一个链表，从尾到头打印链表每个节点的值。<br>思路1：定义一个栈，将链表遍历，将节点数值存入栈中，然后依次出栈<br>代码如下：</p>
<blockquote>
<pre><code>class ListNode:
    def __init__(self, x=None):
        self.val = x
        self.next = None    
class Solution:
    def printListFromTailToHead(self, listNode):
        if listNode.val == None:
            return
        l = []
        head = listNode
        while head:
            l.insert(0, head.val)
            head = head.next
        return l
node1 = ListNode(10)
node2 = ListNode(11)
node3 = ListNode(13)
node1.next = node2
node2.next = node3
S = Solution()
print(S.printListFromTailToHead(node1))
</code></pre></blockquote>
<p>思路2:使用递归，打印当前节点的下一个节点的数值<br>代码如下：</p>
<blockquote>
<pre><code>def printListFromTailToHead1(listNode):
    if listNode!=None:
        if listNode.next!=None:
            printListFromTailToHead1(listNode.next)
        print listNode.val
</code></pre></blockquote>
<p>4.<strong>重建二叉树</strong><br>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<br>思路:先序遍历的第一个值为根节点，找在中序遍历中找到该节点的下标，该节点将树分为左右子树，递归的进行建树<br>代码如下：</p>
<blockquote>
<pre><code>class Node:
    def __init__(self, data, left, right):
        self.data=data
        self.left=left
        self.right=right
def construct_tree(preorder,midorder):
    if len(preorder)==0:
        return None
    root_data=preorder[0]
    i=midorder.index(root_data)
    left=construct_tree(preorder[1:i+1],midorder[:i])
    right=construct_tree(preorder[i+1:],midorder[i+1:])
    return Node(root_data,left,right)
if __name__==&apos;__main__&apos;:
    pre_order = [1, 2, 4, 7, 3, 5, 6, 8]
    mid_order = [4, 7, 2, 1, 5, 3, 8, 6]
    root=construct_tree(pre_order,mid_order)
    print root
</code></pre></blockquote>
<p>5.<strong>用两个栈实现队列</strong><br>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<br>思路：定义两个队列，stack1和stack2，如果push，则将数据存入stack1，如果pop，如果stack2中有数据，则直接弹出，否则先将stack1中数据依次弹出存入stack2中，再弹出stack2一个数据。<br>代码如下：</p>
<blockquote>
<pre><code>class Solution:
    def __init__(self):
        self.stack1=[]
        self.stack2=[]
    def push(self, node):
        self.stack1.append(node)
    def pop(self):
        if self.stack2==[]:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        return self.stack2.pop()
</code></pre></blockquote>
<p>6.<strong>二叉树的下一个结点</strong><br>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<blockquote>
<pre><code>class Solution2:
def GetNext(self, pNode):
    # 输入是一个空节点
    if pNode == None:
        return None
    # 注意当前节点是根节点的情况。所以在最开始设定pNext = None, 如果下列情况都不满足, 说明当前结点为根节点, 直接输出None
    pNext = None
    # 如果输入节点有右子树，则下一个结点是当前节点右子树中最左节点
    if pNode.right:
        pNode = pNode.right
        while pNode.left:
            pNode = pNode.left
        pNext = pNode
    else:
        # 如果当前节点有父节点且当前节点是父节点的左子节点, 下一个结点即为父节点
        if pNode.next and pNode.next.left == pNode:
            pNext = pNode.next
        # 如果当前节点有父节点且当前节点是父节点的右子节点, 那么向上遍历
        # 当遍历到当前节点为父节点的左子节点时, 输入节点的下一个结点为当前节点的父节点
        elif pNode.next and pNode.next.right == pNode:
            pNode = pNode.next
            while pNode.next and pNode.next.right == pNode:
                pNode = pNode.next
            # 遍历终止时当前节点有父节点, 说明当前节点是父节点的左子节点, 输入节点的下一个结点为当前节点的父节点
            # 反之终止时当前节点没有父节点, 说明当前节点在位于根节点的右子树, 没有下一个结点
            if pNode.next:
                pNext = pNode.next
    return pNext
</code></pre></blockquote>
<p>7.<strong>斐波那契数列</strong><br>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。<br>思路1:采用循环，时间复杂度为O(n），代码如下：</p>
<blockquote>
<pre><code>def fabci(n):
    if n==0:
        return 0
    a=0
    b=1
    for i in range(n-1):
        a,b=b,a+b
    return b
</code></pre></blockquote>
<p>思路2：采用递归，复杂度较高，会重复计算相同的值<br>代码如下：</p>
<blockquote>
<pre><code>def fab(n):
      if n==1:
        return 1
      if n==0:
        return 0
      else:
        result=int(fab(n-1))+int(fab(n-2))    
    return result
</code></pre></blockquote>
<p>青蛙跳台阶, 每次可以跳1级或2级<br>思路：其实就是斐波那契数列问题，每次可以跳1级或者两级，则下次的可能性为前两次可能性之和</p>
<blockquote>
<pre><code>def jumpFloor(self, number):
 # write code here
 tempArray = [1, 2]
 if number &gt;= 3:
     for i in range(3, number + 1):
         tempArray[(i + 1) % 2] = tempArray[0] + tempArray[1]
 return tempArray[(number + 1) % 2]
</code></pre></blockquote>
<p>8.<strong>旋转数组的最小数字</strong><br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。给出的所有元素都大于0，若数组大小为0，请返回0。<br>思路：如果遍历一遍，复杂度太高，可以采用二分查找，用两个指针分别指向第一个值和最后一个值，取中间的数，如果该数小于最前面的数，则该数在后面递增的数组里，将前面的指针指向该数，否则在前面递增的数组里，将后面的指针指向该数，将更新后的数组重复做以上操作，当两个指针距离是1时结束，返回后面的指针指向的数字。代码如下：</p>
<blockquote>
<pre><code>def minNumberInRotateArray2(rotateArray):
if len(rotateArray) == 0:
    return 0
front, rear = 0, len(rotateArray) - 1
midIndex = 0  #如果数组把前0个数移到后面，则直接返回第一个
while rotateArray[front] &gt;= rotateArray[rear]:
    if rear - front == 1:
        midIndex = rear
        break
    midIndex = (front + rear) // 2
    if rotateArray[front] == rotateArray[rear] and rotateArray[front] == rotateArray[midIndex]:
        return MinInOrder(rotateArray, front, rear)
    if rotateArray[midIndex] &gt;= rotateArray[front]:
        front = midIndex
    elif rotateArray[midIndex] &lt;= rotateArray[rear]:
        rear = midIndex
return rotateArray[midIndex]
def MinInOrder( array, front, end):
    result = array[0]
    for i in array[front:end + 1]:
        if i &lt; result:
            result = i
    return result
print minNumberInRotateArray2([3,4,5,1,2])
</code></pre></blockquote>
<p>9.矩阵中的路径<br>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。例如 [[a b c e], [s f c s], [a d e e]]矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。<br>思路：递归的采用回溯法</p>
<blockquote>
<pre><code>class Solution:
def hasPath(self, matrix, rows, cols, path):
    if matrix == None or rows &lt; 1 or cols &lt; 1 or path == None:
        return False
    visited = [0] * (rows * cols)
    pathLength = 0
    for row in range(rows):
        for col in range(cols):
            if self.hasPathCore(matrix, rows, cols, row, col, path, pathLength, visited):
                return True
    return False
def hasPathCore(self, matrix, rows, cols, row, col, path, pathLength, visited):
    if len(path) == pathLength:
        return True
    hasPath = False
    if row &gt;= 0 and row &lt; rows and col &gt;= 0 and col &lt; cols and matrix[row * cols + col] == path[pathLength] and not \
    visited[row * cols + col]:
        pathLength += 1
        visited[row * cols + col] = True
        hasPath = self.hasPathCore(matrix, rows, cols, row, col - 1, path, pathLength, visited) or \
                  self.hasPathCore(matrix, rows, cols, row - 1, col, path, pathLength, visited) or \
                  self.hasPathCore(matrix, rows, cols, row, col + 1, path, pathLength, visited) or \
                  self.hasPathCore(matrix, rows, cols, row + 1, col, path, pathLength, visited)
        if not hasPath:
            pathLength -= 1
            visited[row * cols + col] = False
    return hasPath
</code></pre></blockquote>
<p>10.<strong>机器人的运动范围</strong><br>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？<br>思路：机器人从（0，0）开始运动，当它准备进入为（i，j）位置时，判断坐标要求能否进入，如果可以进入，然后递归的进入它相邻的4个格子（i,j-1）,（i-1,j）（i,j+1）,（i+1,j）,采用回溯法，代码如下：</p>
<blockquote>
<pre><code>class Solution:
    def movingCount(self, threshold, rows, cols):
        visited = [False] * (rows * cols)
        count = self.movingCountCore(threshold, rows, cols, 0, 0, visited)
        return count
    def movingCountCore(self, threshold, rows, cols, row, col, visited):
        count = 0
        if self.check(threshold, rows, cols, row, col, visited):
            visited[row * cols + col] = True
            count = 1 + self.movingCountCore(threshold, rows, cols, row-1, col, visited) + \
                        self.movingCountCore(threshold, rows, cols, row+1, col, visited) + \
                        self.movingCountCore(threshold, rows, cols, row, col-1, visited) + \
                        self.movingCountCore(threshold, rows, cols, row, col+1, visited)
        return count
    def check(self, threshold, rows, cols, row, col, visited):
        if row &gt;= 0 and row &lt; rows and col &gt;= 0 and col &lt; cols and self.getDigitSum(row) + self.getDigitSum(col) &lt;= threshold and not visited[row * cols + col]:
            return True
        return False
    def getDigitSum(self, number):
        sum = 0
        while number &gt; 0:
            sum += (number % 10)
            number = number // 10
        return sum
s = Solution()
print(s.movingCount(5, 10, 10))
</code></pre></blockquote>
<p>11.<strong>剪绳子</strong><br>给你一根长度为n的绳子，请把绳子剪成m段 (m和n都是整数，n&gt;1并且m&gt;1)每段绳子的长度记为k[0],k[1],…,k[m].请问k[0]<em>k[1]</em>…<em>k[m]可能的最大乘积是多少？例如，当绳子的长度为8时，我们把它剪成长度分别为2,3,3的三段，此时得到的最大乘积是18.<br>思路1：首先定义函数f(n)为把长度为n的绳子剪成若干段后各段长度乘积的最大值。在剪第一刀时，我们有n-1种选择，也就是说第一段绳子的可能长度分别为1,2,3…..，n-1。因此f(n)=max(f(i)</em>f(n-i))，其中0&lt;i&lt;n。这是一个自上而下的递归公式。由于递归会有大量的不必要的重复计算。一个更好的办法是按照从下而上的顺序计算，也就是说我们先得到f(2),f(3)，再得到f(4),f(5)，直到得到f(n)。当绳子的长度为2的时候，只能剪成长度为1的两段，所以f(2) = 1，当n = 3时，容易得出f(3) = 2;代码如下：</p>
<blockquote>
<pre><code> public class Main {
public static void main(String[] args) {
    System.out.println(maxAfterCutting(8));
}
/**
 * 常规的需要O(n2)的时间复杂度和O(n)的空间复杂度的动态规划思路 题目的意思是:绳子至少是2米，并且必须最少剪一刀。
 */
public static int maxAfterCutting(int length) {
    if (length &lt; 2)
        return 0;
    if (length == 2)
        return 1;
    if (length == 3)
        return 2;
    // 子问题的最优解存储在f数组中，数组中的第i个元素表示把长度为i的绳子剪成若干段后各段长度乘积的最大值。
    int[] f = new int[length + 1];
    f[0] = 0;
    f[1] = 1;
    f[2] = 2;
    f[3] = 3;
    int result = 0;
    for (int i = 4; i &lt;= length; i++) {
        int max = 0;
        for (int j = 1; j &lt;= i / 2; j++) {
            int num = f[j] * f[i - j];
            if (max &lt; num)
                max = num;
        }
        f[i] = max;
    }
    result = f[length];
    return result;
}
</code></pre><p>}</p>
</blockquote>
<p>思路2:贪婪算法，当n&gt;=5时尽可能多的剪长度为3的绳子，剩下剩下的绳子为4时，把绳子剪成两个长度为2的绳子<br>代码如下：</p>
<blockquote>
<pre><code>def long_cut(n):
    if n==3:
        return 2
    if n==2:
        return 1
    if n==0:
        return 0
    counts=0
    for i in range(1,n+1):
        if i%3==0:
            counts+=1
    rest=n-counts*3
    if rest==1:
        return pow(3,counts-1)*4
    elif rest==2:
        return pow(3,counts)*2
    else:
        return pow(3,counts)
    print long_cut(0)
</code></pre></blockquote>
<p>12.<strong>二进制中1的个数</strong><br>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。<br>思路1：先判断整数二进制表示中最右面一位是不是1，接着把输入的整数右移一位，如此反复，直到整数为0<br>代码如下：</p>
<blockquote>
<pre><code>def one_num(n):
counts=0
while n!=0:
    if n&amp;1==1:
        counts+=1
    n=n&gt;&gt;1
return  counts
</code></pre></blockquote>
<p>思路2:调用系统函数，代码如下：</p>
<blockquote>
<pre><code>print bin(n).count(&apos;1&apos;)
</code></pre></blockquote>
<p>思路3:把一个数和该数减一的数做与运算，有多少位1，进行多少次运算，如1100和1011与运算得到1000，代码如下：</p>
<blockquote>
<pre><code>def get_one(n):
    counts=0
    while n!=0:
        counts+=1
        n=n&amp;(n-1)
    return counts
</code></pre></blockquote>
<p>拓展：判断一个数是不是2得整数次幂，代码如下：</p>
<blockquote>
<pre><code>def powerOf2(self, n):
    if n&amp;(n-1) == 0:
        return True
    else:
        return False
</code></pre></blockquote>
<p>拓展：判断两个数的二进制表示有多少位不一样, 直接比较两个数的二进制异或就可以 </p>
<blockquote>
<pre><code>def andOr( m, n):
    diff = m ^ n
    count = 0
    while diff:
        count += 1
        diff = diff &amp; (diff - 1)
    return count
</code></pre></blockquote>
<p>13.<strong>数值的整数次方</strong><br>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br>思路：<br>需要注意的地方:<br>当指数为负数的时候<br>当底数为零切指数为负数的情况<br>在判断底数base是不是等于0的时候,不能直接写base==0, 因为计算机内表示小数时有误差,只能判断他们的差的绝对值是不是在一个很小的范围内<br>当n为偶数, a^n = a^(n/2) <em> a^(n/2)<br>当n为奇数, a^n = a^((n-1)/2) </em> a^((n-1)/2)) * a<br>利用右移一位运算代替除以2<br>利用位与运算代替了求余运算法%来判断一个数是奇数还是偶数<br>优化代码速度<br>代码如下：</p>
<blockquote>
<pre><code>def Power( base, exponent):
    if exponent == 0:
        return 1
    if exponent == 1:
        return base
    if exponent == -1:
        return 1 / base
    result = Power(base, exponent &gt;&gt; 1)
    result *= result
    if (exponent &amp; 0x1) == 1:
        result *= base
    return result
</code></pre></blockquote>
<p>14.<strong>打印从1到最大的n位整数</strong><br>输入数字n, 按顺序打印从1最大的n位十进制数<br>比如输入3, 则打印出1、2、3、到最大的3位数即999<br>思路：用字符串来存储数字</p>
<blockquote>
<pre><code>public class Main {
public static void Print1ToMaxOfNDigits_2(int n) {
    if (n &lt;= 0) {
        return;
    }
    StringBuffer number = new StringBuffer();
    for (int i = 0; i &lt; n; i++) {
        number.append(&apos;0&apos;);
    }
    while (!Increment(number)) {
        PrintNumber(number);
    }
}
public static boolean Increment(StringBuffer s) {
    boolean isOverflow = false;
    int nTakeOver = 0;
    int nLength = s.length();
    for (int i = nLength - 1; i &gt;= 0; i--) {
        int nSum = s.charAt(i) - &apos;0&apos; + nTakeOver;
        if (i == nLength - 1) {
            nSum++;
        }
        if (nSum &gt;= 10) {
            if (i == 0) {
                isOverflow = true;
            } else {
                nSum -= 10;
                nTakeOver = 1;
                s.setCharAt(i, (char) (&apos;0&apos; + nSum));
            }
        } else {
            s.setCharAt(i, (char) (&apos;0&apos; + nSum));
            break;
        }
    }
    return isOverflow;
}
public static void PrintNumber(StringBuffer s) {
    boolean isBeginning0 = true;
    for (int i = 0; i &lt; s.length(); i++) {
        if (isBeginning0 &amp;&amp; s.charAt(i) != &apos;0&apos;) {
            isBeginning0 = false;
        }
        if (!isBeginning0) {
            System.out.print(s.charAt(i));
        }
    }
    System.out.println();
}
public static void main(String[] args) {
    Print1ToMaxOfNDigits_2(2);
}
</code></pre><p> }</p>
</blockquote>
<p>15.<strong>在O(1)时间内删除链表结点</strong><br>给定单向链表的头指针和一个结点指针,定义一个函数在O(1)时间删除该结点<br>思路:将要删除的节点的next复制到当前节点，删除当前节点的next，代码如下：</p>
<blockquote>
<pre><code>class ListNode:
    def __init__(self, x=None):
        self.val = x
        self.next = None
    def __del__(self):
        self.val = None
        self.next = None
class Solution:
    def DeleteNode(self, pListHead, pToBeDeleted):
        if not pListHead or not pToBeDeleted:
            return None
        if pToBeDeleted.next != None:
            pNext = pToBeDeleted.next
            pToBeDeleted.val = pNext.val
            pToBeDeleted.next = pNext.next
            pNext.__del__()
        elif pListHead == pToBeDeleted:
            pToBeDeleted.__del__()
            pListHead.__del__()
        else:
            try:
                pNode = pListHead
                while pNode.next != pToBeDeleted:
                    pNode = pNode.next
                pNode.next = None
                pToBeDeleted.__del__()
            except:
                return False    #如果没有要删除节点
        return True
</code></pre></blockquote>
<p>16.<strong>删除链表中重复的结点</strong><br>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。<br>例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5<br>思路：遍历整个链表，如果当前节点pNode的值和下一个节点的值相同，那么就是重复节点，要删除，我们把当前的前一个节点pPreNode和后面值比当前节点大的值的</p>
<blockquote>
<pre><code>class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
class Solution:
    def deleteDuplication(self, pHead):
        if pHead == None:
            return
        preHead = None
        pNode = pHead
        while pNode != None:
            needDelete = False
            nextNode = pNode.next
            if nextNode != None and nextNode.val == pNode.val:
                needDelete = True
            if needDelete == False:
                preHead = pNode
                pNode = pNode.next
            else:
                nodeVal = pNode.val
                pToBeDel = pNode
                while pToBeDel != None and pToBeDel.val == nodeVal:
                    pToBeDel = pToBeDel.next
                if preHead == None:
                    pHead = pToBeDel
                    pNode = pToBeDel
                    continue
                else:
                    preHead.next = pToBeDel
                pNode = preHead
        return pHead
</code></pre></blockquote>
<p> 17.<strong>正则表达式匹配</strong><br> 请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配<br>代码如下：</p>
<blockquote>
<pre><code>class Solution:
# s, pattern都是字符串
    def match(self, s, pattern):
        if not s or not pattern:
            return False
    # 如果s和pattern匹配, 直接True
        if s == pattern:
            return True
    # 如果pattern为&apos;&apos;, 因为s和pattern不相等, 直接False
        elif pattern == &apos;&apos;:
            return False
    # 当s为&apos;&apos;, 如果pattern为&apos;.&apos;, 则返回True
    # 当s为&apos;&apos;, 如果pattern长度为1且不为&apos;.&apos;, 或者pattern第二个字符不是*, 则pattern不可能为空, 返回False
    # 若pattern长度不为1, 且第二个字符为*, pattern还有空的可能, 从第三个字符开始迭代
        elif s == &apos;&apos;:
            if pattern == &quot;.&quot;:
                return True
            elif len(pattern) == 1 or pattern[1] != &apos;*&apos;:
                return False
            else:
                return self.match(s, pattern[2:])
    # 如果pattern长度不小于二, 而且pattern的第二个字符不是*的情况下
    # 当 pattern[0] 不等于s[0], 且不为 . 的时候, s和pattern必不相等
    # 否则, s 和 pattern 都右移一位, 继续比较
        if len(pattern) &gt;= 2 and pattern[1] != &apos;*&apos;:
            if s[0] != pattern[0] and pattern[0] != &apos;.&apos;:
                return False
            else:
                return self.match(s[1:], pattern[1:])
    # 如果pattern长度不小于2, 且pattern第二个字符为*的情况下
    # 如果s[0]不等于pattern[0], 且pattern[0]不为 . , 那么第一位比较不成功, pattern必须后移两位继续比较后面是否能和s第一位匹配
    # 如果s[0]等于pattern[0], 或者pattern[0]为 . , 第一位匹配, 那么会有
    # 1. aaa 和 a*a 这种情况, 星号代表了多个a, 因此s需要不断右移一位继续比较
    # 2. a 和 a*a 中这情况, 这时候星号代表0个a, 因此s不需要右移, pattern需要右移两位
    # 3. abc 和 a*bc 这种情况, 星号代表了1个a, s右移一位, pattern右移两位继续比较
        elif len(pattern) &gt;= 2 and pattern[1] == &apos;*&apos;:
            if s[0] != pattern[0] and pattern[0] != &apos;.&apos;:
                return self.match(s, pattern[2:])
            else:
                return self.match(s[1:], pattern) or self.match(s, pattern[2:]) or self.match(s[1:], pattern[2:])
    # 除去上述pattern不小于2情况, 只剩下pattern等于1的情况, 因此如果pattern为&quot;.&quot;, 而且s长度为1, 返回True
        elif pattern == &apos;.&apos; and len(s) == 1:
            return True
        return False
s = Solution()
print(s.match(&apos;aaa&apos;, &apos;a*a&apos;))
</code></pre></blockquote>
<p>18.<strong>表示数值的字符串</strong><br>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。<br>思路1：根据规则判断即可，代码如下：</p>
<blockquote>
<pre><code>class Solution:
# s字符串
    def isNumeric(self, s):
        if s == None or len(s) &lt;= 0:
            return False
        aList = [w.lower() for w in s]
        if &apos;e&apos; in aList:
            indexE = aList.index(&apos;e&apos;)
            front = aList[:indexE]
            behind = aList[indexE+1:]
            if &apos;.&apos; in behind or len(behind) == 0:
                return False
            isFront = self.scanDigit(front)
            isBehind = self.scanDigit(behind)
            return isBehind and isFront
        else:
            isNum = self.scanDigit(aList)
            return isNum
    def scanDigit(self, alist):
        dotNum = 0
        allowVal = [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;+&apos;, &apos;-&apos;, &apos;.&apos;, &apos;e&apos;]
        for i in range(len(alist)):
            if alist[i] not in allowVal:
                return False
            if alist[i] == &apos;.&apos;:
                dotNum += 1
            if alist[i] in &apos;+-&apos; and i != 0:
                return False
        if dotNum &gt; 1:
            return False
        return True
# Python trick
</code></pre></blockquote>
<p>思路2:使用巧妙方法，直接将输入字符串进行强制转化为数值型，如果成功则字符串为合法的，否则不合法，代码如下：</p>
<blockquote>
<pre><code>def isNumeric2(self, s):
    try:
        float(s)
        return True
    except:
        return False
print(isNumeric(&apos;-12.5e2&apos;))
</code></pre></blockquote>
<p>19.<strong>调整数组顺序使奇数在偶数前面</strong><br>思路1:定义两个指针front和rear，初始化front指向数组第一个数，rear指向数组最后一个数，在front和rear没有指向同一个指针之前，front向后移动找偶数，rear向前移动找奇数，交换两个数，直至指向同一个数，代码如下：</p>
<blockquote>
<pre><code>class Solution:
# 一个类似于快排的方法, 只是简单的满足了奇数在前,偶数在后, 奇数的顺序发生了改变
    def reOrderArray(self, array):
        if len(array) &lt; 1:
            return
        elif len(array) == 1:
            return array
        front = 0
        rear = len(array)-1
        while front &lt;= rear:
            while array[front] &amp; 0x1 == 1:
                front += 1
            while array[rear] &amp; 0x1 == 0:
                rear -= 1
            array[front], array[rear] = array[rear], array[front]
        array[front], array[rear] = array[rear], array[front]
        return array
</code></pre></blockquote>
<p>思路2:定义两个新数组，分别存储奇数和偶数，然后加到一块，代码如下：</p>
<blockquote>
<pre><code>def reOrderArray3(self, array):
    if len(array) &lt; 1:
        return []
    if len(array) == 1:
        return array
    arrayOdd = []
    arrayEven = []
    for num in array:
        if num &amp; 0x1:
            arrayOdd.append(num)
        else:
            arrayEven.append(num)
    return arrayOdd+arrayEven
</code></pre></blockquote>
<p>思路3:类似于思路2，更简洁的写法，代码如下：</p>
<blockquote>
<pre><code>def reOrderArray2(self, array):
    left = [x for x in array if x &amp; 1]
    right = [x for x in array if not x &amp; 1]
    return left + right
</code></pre></blockquote>
<p>20.<strong>链表中倒数第k个节点</strong><br>输入一个链表，输出该链表中倒数第k个结点。<br>思路：定义两个指针，第一个指针从头节点向后走k-1次，然后第二个指针和第一个指针同时向后走，第一个指针走到最后的尾节点时，第二个指针即指向倒数第k个节点,代码如下：</p>
<blockquote>
<pre><code>class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
class Solution:
    def FindKthToTail(self, head, k):
        if head == None or k &lt;= 0:
            return None
        pAHead = head
        pBehind = None
        for i in range(k-1):
            if pAHead.next != None:
                pAHead = pAHead.next
            else:
                return None
        pBehind = head
        while pAHead.next != None:
            pAHead = pAHead.next
            pBehind = pBehind.next
        return pBehind
node1 = ListNode(10)
node2 = ListNode(11)
node3 = ListNode(13)
node1.next = node2
node2.next = node3
S = Solution()
print(S.FindKthToTail(node1, 2).val)
</code></pre></blockquote>
<p>21.<strong>链表中环的入口节点</strong><br>一个链表中包含环，请找出该链表的环的入口结点。<br>思路：定义两个指针，p1和p2指向头节点，如果链表中的环有n个节点，p1指针先向后走n步，然后两个指针以相同的速度向后移动，当第二个指针指向环入口时，第一个环已经已经绕着环走了一圈，又回到入口处节点，首先求n，用两个指针一快一慢，如果相遇则证明有环，从相遇节点出发，一边向后移动，一边计数，当再次回到该节点时，可以得到环中点的数。代码如下：</p>
<blockquote>
<pre><code>class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
class Solution:
    def MeetingNode(self, pHead):
        if pHead == None:
            return None
        pSlow = pHead.next
        if pSlow == None:
            return None
        pFast = pSlow.next
        while pFast:
            if pSlow == pFast:
                return pSlow
            pSlow = pSlow.next
            pFast = pFast.next
            if pFast:
                pFast = pFast.next
    def EntryNodeOfLoop(self, pHead):
        meetingNode = self.MeetingNode(pHead)
        if not meetingNode:
            return None
        NodeLoop = 1
        flagNode = meetingNode
        while flagNode.next != meetingNode:
            NodeLoop += 1
            flagNode = flagNode.next
        pFast = pHead
        for i in range(NodeLoop):
            pFast = pFast.next
        pSlow = pHead
        while pFast != pSlow:
            pFast = pFast.next
            pSlow = pSlow.next
        return pFast
</code></pre></blockquote>
<p>22.<strong>翻转链表</strong><br>输入一个链表，反转链表后</p>
<blockquote>
<pre><code>class ListNode:
def __init__(self, x):
    self.val = x
    self.next = None
class Solution:
    # 返回ListNode
    def ReverseList(self, pHead):
        pReversedHead = None
        pNode = pHead
        pPrev = None
        while pNode != None:
            pNext = pNode.next
            if pNext == None:
                pReversedHead = pNode
            pNode.next = pPrev
            pPrev = pNode
            pNode = pNext
        return pReversedHead
# 递归实现反转链表
    def ReverseListRec(self, pHead):
        if not pHead or not pHead.next:
            return pHead
        else:
            pReversedHead = self.ReverseList(pHead.next)
            pHead.next.next = pHead
            pHead.next = None
            return pReversedHead
node1 = ListNode(10)
node2 = ListNode(11)
node3 = ListNode(13)
node1.next = node2
node2.next = node3
S = Solution()
p = S.ReverseList(node1)
print(p.val)
</code></pre></blockquote>
<p>23.<strong>合并两个排序链表</strong><br>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。<br>思路：建立一个新的链表，分别比较大小，递归的合并链表，代码如下：</p>
<blockquote>
<pre><code>class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
class Solution:
    # 返回合并后列表
    def Merge(self, pHead1, pHead2):
        if pHead1 == None:
            return pHead2
        elif pHead2 == None:
            return pHead1
        pMergedHead = None
        if pHead1.val &lt; pHead2.val:
            pMergedHead = pHead1
            pMergedHead.next = self.Merge(pHead1.next, pHead2)
        else:
            pMergedHead = pHead2
            pMergedHead.next = self.Merge(pHead1, pHead2.next)
        return pMergedHead
</code></pre></blockquote>
<p>24.<strong>树的子结构</strong><br>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）<br>思路：在A树中找和树B根节点值一样的节点R，再判断树A中以R为根节点的子树是不是包含和B一样的结构，代码如下：</p>
<blockquote>
<pre><code>class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
class Solution:
    def HasSubtree(self, pRoot1, pRoot2):
        result = False
        if pRoot1 != None and pRoot2 != None:
            if pRoot1.val == pRoot2.val:
                result = self.DoesTree1haveTree2(pRoot1, pRoot2)
            if not result:
                result = self.HasSubtree(pRoot1.left, pRoot2)
            if not result:
                result = self.HasSubtree(pRoot1.right, pRoot2)
        return result
    # 用于递归判断树的每个节点是否相同
    # 需要注意的地方是: 前两个if语句不可以颠倒顺序
    # 如果颠倒顺序, 会先判断pRoot1是否为None, 其实这个时候pRoot2的结点已经遍历完成确定相等了, 但是返回了False, 判断错误
    def DoesTree1haveTree2(self, pRoot1, pRoot2):
        if pRoot2 == None:
            return True
        if pRoot1 == None:
            return False
        if pRoot1.val != pRoot2.val:
            return False
        return self.DoesTree1haveTree2(pRoot1.left, pRoot2.left) and self.DoesTree1haveTree2(pRoot1.right, pRoot2.right)
</code></pre></blockquote>
<p>25.<strong>二叉树的镜像</strong><br>操作给定的二叉树，将其变换为源二叉树的镜像。<br>思路：先前序遍历这棵树的每个节点，如果遍历到的节点有子节点，就交换它的两个子节点。<br>递归交换，代码如下：</p>
<blockquote>
<pre><code>class Solution:
    # 递归实现
    def Mirror(self, root):
        if root == None:
            return
        if root.left == None and root.right == None:
            return root
        pTemp = root.left
        root.left = root.right
        root.right = pTemp
        self.Mirror(root.left)
        self.Mirror(root.right)
    # 非递归实现
    def Mirror2(self, root):
        if root == None:
            return
        stackNode = []
        stackNode.append(root)
        while len(stackNode) &gt; 0:
            nodeNum = len(stackNode) - 1
            tree = stackNode[nodeNum]
            stackNode.pop()
            nodeNum -= 1
            if tree.left != None or tree.right != None:
                tree.left, tree.right = tree.right, tree.left
            if tree.left:
                stackNode.append(tree.left)
                nodeNum += 1
            if tree.right:
                stackNode.append(tree.right)
                nodeNum += 1
    # 非递归实现
    def MirrorNoRecursion(self, root):
        if root == None:
            return
        nodeQue = [root]
        while len(nodeQue) &gt; 0:
            curLevel, count = len(nodeQue), 0
            while count &lt; curLevel:
                count += 1
                pRoot = nodeQue.pop(0)
                pRoot.left, pRoot.right = pRoot.right, pRoot.left
                if pRoot.left:
                    nodeQue.append(pRoot.left)
                if pRoot.right:
                    nodeQue.append(pRoot.right)
</code></pre></blockquote>
<p>26.<strong>对称的二叉树</strong><br>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。<br>思路：主要就是把叶子节点的None节点也加入到遍历当中。按照前序遍历二叉树，存入一个序列中。然后按照和前序遍历对应的先父节点，然后右子节点，最后左子节点遍历二叉树，存入一个序列。如果前后两个序列相等，那么说明二叉树是对称的。<br>递归，代码如下：</p>
<blockquote>
<pre><code>class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
class Solution:
    def isSymmetrical(self, pRoot):
         return self.selfIsSymmetrical(pRoot, pRoot)
    def selfIsSymmetrical(self, pRoot1, pRoot2):
        if pRoot1 == None and pRoot2 == None:
            return True
        if pRoot1 == None or pRoot2 == None:
            return False
        if pRoot1.val != pRoot2.val:
            return False
        return self.selfIsSymmetrical(pRoot1.left, pRoot2.right) and self.selfIsSymmetrical(pRoot1.right, pRoot2.left)
</code></pre></blockquote>
<p>非递归实现判断二叉树是否对称,代码如下：</p>
<blockquote>
<pre><code>class Solution2:
    def isSymmetrical(self, pRoot):
        preList = self.preOrder(pRoot)
        mirrorList = self.mirrorPreOrder(pRoot)
        if preList == mirrorList:
            return True
        return False
    def preOrder(self, pRoot):
        if pRoot == None:
            return [None]
        treeStack = []
        output = []
        pNode = pRoot
        while pNode or len(treeStack) &gt; 0:
            while pNode:
                treeStack.append(pNode)
                output.append(pNode.val)
                pNode = pNode.left
                if not pNode:
                    output.append(None)
            if len(treeStack):
                pNode = treeStack.pop()
                pNode = pNode.right
                if not pNode:
                    output.append(None)
        return output
    def mirrorPreOrder(self, pRoot):
        if pRoot == None:
            return [None]
        treeStack = []
        output = []
        pNode = pRoot
        while pNode or len(treeStack) &gt; 0:
            while pNode:
                treeStack.append(pNode)
                output.append(pNode.val)
                pNode = pNode.right
                if not pNode:
                    output.append(None)
            if len(treeStack):
                pNode = treeStack.pop()
                pNode = pNode.left
                if not pNode:
                    output.append(None)
        return output
</code></pre></blockquote>
<p>27.<strong>顺时针打印矩阵</strong><br>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.<br>思路1：首先需要判断每一步开始是的坐标点是否满足小于行数的一半且小于列数的一半，在最后一圈中，可能出现仅能向右走一行，仅能向右走一行向下走一列，向右走一行向下走一列向左走一行，能走完整一圈，一共四种情况。其中只有能向左走一行必然发生，不必判断，剩余的都需要判断发生条件。</p>
<blockquote>
<pre><code>class Solution:
    # matrix类型为二维列表，需要返回列表
    def PrintMatrix(self, matrix):
        printArr = []
        if matrix == None:
            return
        if matrix == []:
            return []
        start = 0               # 每次循环时起始点
        rows = len(matrix)   # 列数
        columns = len(matrix[0])   # 行数
        while columns &gt; 2 * start and rows &gt; 2 * start:
            endX = columns - 1 - start
            endY = rows - 1 - start
            # 从左到右将数字存入printArr
            for i in range(start, endX+1):
                number = matrix[start][i]
                printArr.append(number)
            # 从上到下将数字存入printArr
            if start &lt; endY:
                for i in range(start+1, endY+1):
                    number = matrix[i][endX]
                    printArr.append(number)
            # 从右到左将数字存入printArr
            if start &lt; endX and start &lt; endY:
                for i in range(endX-1, start-1, -1):
                    number = matrix[endY][i]
                    printArr.append(number)
            # 从下到上将数字存入printArr
            if start &lt; endX and start &lt; endY-1:
                for i in range(endY-1, start, -1):
                    number = matrix[i][start]
                    printArr.append(number)
            start += 1
        return printArr
matrix = [[1,  2,  3,  4],
          [5,  6,  7,  8],
          [9, 10, 11, 12],
          [13, 14, 15, 16]]
S = Solution()
print  S.PrintMatrix(matrix)
</code></pre></blockquote>
<p>思路2:这个相对比较容易理解，但复杂度相对高点，每次都打印第一行，然后删除第一行并将矩阵逆时针旋转90度，重复上述操作直到矩阵为空，代码如下：</p>
<blockquote>
<pre><code>class Solution:
    def printMatrix(self, matrix):
        result = []
        while(matrix):
            result+=matrix.pop(0)
            if not matrix or not matrix[0]:
                break
            matrix = self.turn(matrix)
        return result
    def turn(self,matrix):
        num_r = len(matrix)
        num_c = len(matrix[0])
        newmat = []
        for i in range(num_c):
            newmat2 = []
            for j in range(num_r):
                newmat2.append(matrix[j][i])
            newmat.append(newmat2)
        newmat.reverse()
        return newmat
matrix = [[1,  2,  3,  4],
          [5,  6,  7,  8],
          [9, 10, 11, 12],
          [13, 14, 15, 16]]
S = Solution()
print  S.printMatrix(matrix)
</code></pre></blockquote>
<p>28.<strong>包含min函数的栈</strong><br>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。<br>思路：用一个辅助栈一直保存和更新最小值，始终保持栈顶元素最小，第二个第二小，代码如下：</p>
<blockquote>
<pre><code>class Solution:
    def __init__(self):
        self.stack = []
        self.minStack = []
    def push(self, node):
        self.stack.append(node)
        if self.minStack == [] or node &lt; self.min():
            self.minStack.append(node)
        else:
            temp = self.min()
            self.minStack.append(temp)
    def pop(self):
        if self.stack == [] or self.minStack == []:
            return None
        self.minStack.pop()
        self.stack.pop()
    def top(self):
        return self.stack[-1]
    def min(self):
        return self.minStack[-1]
</code></pre></blockquote>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/算法/">算法</a>
</div>


</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yoursite.com/2017/10/18/剑指offer/" data-title="剑指offer | Cindy" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2017/10/18/N皇后问题/" title="N皇后问题">
  <strong>上一篇：</strong><br/>
  <span>
  N皇后问题</span>
</a>
</div>


<div class="next">
<a href="/2017/10/17/实现一个包含insert、search、和startWith的前缀树/"  title="实现一个包含insert、search、和startWith的前缀树">
 <strong>下一篇：</strong><br/> 
 <span>实现一个包含insert、search、和startWith的前缀树
</span>
</a>
</div>

</nav>

	


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/机器学习/" title="机器学习">机器学习<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/爬虫/" title="爬虫">爬虫<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>24</sup></a></li>
		  
		
		</ul>
</div>


  

  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Cassiel in BISTU. <br/>
			</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="Liberty_zheng">Liberty_zheng</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>









<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
